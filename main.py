import streamlit as st
import random
import json
import time
from datetime import datetime

# í•œì ë°ì´í„° (í™•ì¥ëœ ë²„ì „)
HANJA_DATA = {
    "è¿": ("ë¶“", "ìœ¨"),
    "æ›°": ("ë§í•˜ë‹¤", "ì™ˆ"),
    "æ­¥": ("ê±·ë‹¤", "ë³´"),
    "ç«‹": ("ì„œë‹¤", "ë¦½"),
    "åŠ›": ("í˜", "ë ¥"),
    "å®€": ("ì§‘", "ë©´"),
    "è€‚": ("ëŠ™ë‹¤", "ë¡œ"),
    "æ³•": ("ë²•", "ë²•"),
    "å¤": ("ì˜›", "ê³ "),
    "å‰µ": ("ë¹„ë¡¯í• ", "ì°½"),
    "æ–°": ("ìƒˆë¡œìš¸", "ì‹ "),
    "ç”²": ("ê°‘ì˜·", "ê°‘"),
    "å®ˆ": ("ì§€í‚¬", "ìˆ˜"),
    "åµ": ("ì•Œ", "ë€"),
    "æœ‰": ("ìˆì„", "ìœ "),
    "æ‚Ÿ": ("ê¹¨ë‹¬ì„", "ì˜¤"),
    "æ·¸": ("ë§‘ì„", "ì²­"),
    "æ½”": ("ê¹¨ë—í•˜ë‹¤", "ê²°"),
    "ä¸": ("ì•„ë‹", "ë¶ˆ"),
    "è¨€": ("ë§ì”€", "ì–¸"),
    "é•·": ("ê¸¸", "ì¥"),
    "çŸ­": ("ì§§ì„", "ë‹¨"),
    "è©•": ("í‰í• ", "í‰"),
    "è½": ("ë–¨ì–´ì§ˆ", "ë½"),
    "é»": ("ì ", "ì "),
    "éˆ": ("ë‘”í• ", "ë‘”"),
    "ç­†": ("ë¶“", "í•„"),
    "å€Ÿ": ("ë¹Œë¦´", "ì°¨"),
    "é¨": ("íƒˆ", "ê¸°"),
    "é‚„": ("ëŒì•„ê°ˆ", "í™˜"),
    "ç›œ": ("ë„ë‘‘", "ë„"),
    "è³Š": ("ë„ë‘‘", "ì "),
    "é¢¨": ("ë°”ëŒ", "í’"),
    "è": ("ë“¤ì„", "ë¬¸"),
    "è«·": ("í’ìí• ", "í’"),
    "åˆº": ("ì°Œë¥¼", "ì"),
    "å‰½": ("ê²ë°•í• ", "í‘œ"),
    "ç«Š": ("í›”ì¹ ", "ì ˆ"),
    "èˆ": ("ë²„ë¦´", "ì‚¬"),
    "å¾": ("ì¢‡ì„", "ì¢…"),
    "è›™": ("ê°œêµ¬ë¦¬", "ì™€"),
    "å¼˜": ("ë„“ì„", "í™"),
    "ç›Š": ("ì´ë¡œìš¸", "ìµ"),
    "é–“": ("ì‚¬ì´", "ê°„"),
    "è¦‹": ("ë³¼", "ê²¬"),
    "é‡‘": ("ì‡ ", "ê¹€"),
    "å¦‚": ("ê°™ì„", "ì—¬"),
    "çŸ³": ("ëŒ", "ì„"),
    "å…«": ("ì—¬ëŸ", "íŒ”"),
    "å•†": ("ì¥ì‚¬", "ìƒ"),
    "æ³¥": ("ì§„í™", "ì´"),
    "ç”°": ("ë°­", "ì „"),
    "ç‹—": ("ê°œ", "êµ¬"),
    "ç¢§": ("í‘¸ë¥¼", "ë²½"),
    "æ˜Œ": ("ì°½ì„±í• ", "ì°½"),
    "ç‰›": ("ì†Œ", "ìš°"),
    "å ´": ("ë§ˆë‹¹", "ì¥"),
    "æ©Ÿ": ("ê¸°í‹€", "ê¸°"),
    "æ™º": ("ì§€í˜œ", "ì§€"),
    "è‡´": ("ì´ë£°", "ì¹˜"),
    "è²ª": ("íƒí• ", "íƒ"),
    "å¤«": ("ì§€ì•„ë¹„", "ë¶€"),
    "å¾‡": ("ì«“ë‹¤", "ìˆœ"),
    "è²¡": ("ì¬ë¬¼", "ì¬"),
    "å›º": ("êµ³ì„", "ê³ "),
    "åŸ·": ("ì¡ì„", "ì§‘"),
    "é€š": ("í†µí• ", "í†µ"),
    "æœ": ("ë§‰ì„", "ë‘"),
    "é–€": ("ë¬¸", "ë¬¸"),
    "å‡º": ("ë‚˜ê°ˆ", "ì¶œ"),
    "å¾": ("ì¹ ", "ì •"),
    "æ˜": ("ëª…ë‚˜ë¼", "ëª…"),
    "å‡": ("ë¹Œë¦´", "ê°€"),
    "é“": ("ê¸¸", "ë„"),
    "èµ°": ("ë‹¬ë¦´", "ì£¼"),
    "è‚–": ("ë‹®ì„", "ì´ˆ"),
    "çˆ²": ("ë ", "ìœ„"),
    "ç‹": ("ì„ê¸ˆ", "ì™•"),
    "æŒ": ("ê°€ì§ˆ", "ì§€"),
    "æ–§": ("ë„ë¼", "ë¶€"),
    "ç–": ("ì†Œí†µí• ", "ì†Œ"),
    "å": ("ë²¼ìŠ¬ì•„ì¹˜", "ë¦¬"),
    "èˆˆ": ("í¥í• ", "í¥"),
    "äº¡": ("ë§í• ", "ë§"),
    "æ«¨": ("ê±°ë¨•ì˜»ë‚˜ë¬´", "ë…¸"),
    "æ«ƒ": ("ê¶¤", "ê¶¤"),
    "åˆ»": ("ìƒˆê¸°ë‹¤", "ê°"),
    "æ±‚": ("êµ¬í• ", "êµ¬"),
    "åŠ": ("ì¹¼", "ê²€"),
    "æ ª": ("ê·¸ë£¨í„°ê¸°", "ì£¼"),
    "å¾…": ("ê¸°ë‹¤ë¦´", "ëŒ€"),
    "å…": ("í† ë¼", "í† "),
    "è† ": ("ì•„êµ", "êµ"),
    "æŸ±": ("ê¸°ë‘¥", "ì£¼"),
    "é¼“": ("ë‘ë“œë¦´", "ê³ "),
    "ç‘Ÿ": ("ê±°ë¬¸ê³ ", "ìŠ¬"),
    "å°¾": ("ê¼¬ë¦¬", "ë¯¸"),
    "ç”Ÿ": ("ë‚ ", "ìƒ"),
    "ä¹‹": ("~ì˜", "ì§€"),
    "ä¿¡": ("ë¯¿ì„", "ì‹ "),
    "é£Ÿ": ("ë¨¹ì„", "ì‹"),
    "ä½©": ("ì°°", "íŒ¨"),
    "éˆ´": ("ë°©ìš¸", "ë ¹"),
    "èª¡": ("ê²½ê³„í• ", "ê³„"),
    "æ¾": ("ì†Œë‚˜ë¬´", "ì†¡"),
    "éƒ½": ("ë„ì", "ë„"),
    "å“¡": ("ì¸ì›", "ì›"),
    "æ²™": ("ëª¨ë˜", "ì‚¬"),
    "é‡": ("ë“¤", "ì•¼"),
    "é¼ ": ("ì¥", "ì„œ"),
    "å©š": ("í˜¼ì¸", "í˜¼"),
    "å¦»": ("ì•„ë‚´", "ì²˜"),
    "é«˜": ("ë†’ì„", "ê³ "),
    "éº—": ("ê³ ìš¸", "ë ¤"),
    "å…¬": ("ê³µë³€ë ", "ê³µ"),
    "å¿«": ("ì¾Œí• ", "ì¾Œ"),
    "éŒ¦": ("ë¹„ë‹¨", "ê¸ˆ"),
    "å…„": ("í˜•", "í˜•"),
    "å‹": ("ìš°ì• ", "ìš°"),
    "å¼Ÿ": ("ì•„ìš°", "ì œ"),
    "å—": ("ë‚¨ë…˜", "ë‚¨"),
    "å…¥": ("ë“¤", "ì…"),
    "ç´": ("ë“¤ì¼", "ë‚©"),
    "å¯©": ("ìì„¸í•˜ë‹¤", "ì‹¬"),
    "å•": ("ë¬»ë‹¤", "ë¬¸"),
    "ç·¨": ("ì±… ëˆ", "í¸"),
    "ç™¼": ("í”¼ë‹¤", "ë°œ"),
    "å¿˜": ("ìŠë‹¤", "ë§"),
    "æ¯": ("ì‰¬ë‹¤", "ì‹"),
    "åŠŸ": ("ê³µ", "ê³µ"),
    "è€…": ("ì‚¬ëŒ", "ì"),
    "äº¦": ("ë˜í•œ", "ì—­"),
    "èƒ½": ("í•  ìˆ˜ ìˆë‹¤", "ëŠ¥"),
    "å­¸": ("ë°°ìš¸", "í•™"),
    "å‹¿": ("ë§ë¼", "ë¬¼"),
    "ä»Š": ("ì´ì œ", "ê¸ˆ"),
    "è€Œ": ("ê·¸ë¦¬ê³ ", "ì´"),
    "å¹´": ("í•´", "ë…„"),
    "è®€": ("ì½ë‹¤", "ë…"),
    "å¿…": ("ë°˜ë“œì‹œ", "í•„"),
    "æ°£": ("ê¸°ìš´", "ê¸°"),
    "å¿µ": ("ìƒê°", "ë…"),
    "ä¸»": ("ì£¼ë¡œí•˜ë‹¤", "ì£¼"),
    "å…ˆ": ("ë¨¼ì €", "ì„ "),
    "æ¡‚": ("ê³„ìˆ˜ë‚˜ë¬´", "ê³„"),
    "æ": ("ê°€ì§€", "ì§€"),
    "å¤–": ("ë°”ê¹¥", "ì™¸"),
    "å…§": ("ì•ˆ", "ë‚´"),
    "å‰›": ("êµ³ì„¸ë‹¤", "ê°•"),
    "ç¦®": ("ì˜ˆì ˆ", "ë¡€"),
    "ç¾©": ("ì˜³ë‹¤", "ì˜"),
    "æ¥": ("ë¶€ë„ëŸ½ë‹¤", "ì¹˜"),
    "æ‹›": ("ë¶€ë¥´ë‹¤", "ì´ˆ"),
    "å—": ("ë°›ë‹¤", "ìˆ˜"),
    "è«–": ("ë…¼í• ", "ë¡ "),
    "æ•…": ("ì—°ê³ ", "ê³ "),
    "å…¶": ("ê·¸", "ê¸°"),
    "æµ·": ("ë°”ë‹¤", "í•´"),
    "æ“‡": ("ê°€ë¦¬ë‹¤", "íƒ"),
    "æµ": ("íë¥´ë‹¤", "ë¥˜"),
    "æ·±": ("ê¹Šë‹¤", "ì‹¬"),
    "ç ´": ("ê¹¨ëœ¨ë¦¬ë‹¤", "íŒŒ"),
    "å¿ƒ": ("ë§ˆìŒ", "ì‹¬"),
    "åŒ": ("ê°™ì„", "ë™"),
    "é«”": ("ëª¸", "ì²´"),
    "ç•°": ("ë‹¤ë¥´ë‹¤", "ì´"),
    "è²": ("ì†Œë¦¬", "ì„±"),
    "æ¸¾": ("ëª¨ë‘", "í˜¼"),
    "ç„¶": ("ê·¸ëŸ¬í•˜ë‹¤", "ì—°"),
    "åœ˜": ("ëª¨ì´ë‹¤", "ë‹¨"),
    "åºŠ": ("í‰ìƒ", "ìƒ"),
    "å¤¢": ("ê¿ˆ", "ëª½"),
    "å’¸": ("ëª¨ë‘", "í•¨"),
    "å·®": ("ë‹¤ë¥¼", "ì°¨"),
    "ä½¿": ("ì‚¬ì‹ ", "ì‚¬"),
    "çƒ": ("ê¹Œë§ˆê·€", "ì˜¤"),
    "é£›": ("ë‚ ", "ë¹„"),
    "æ¢¨": ("ë°°", "ì´"),
    "ç“œ": ("ì˜¤ì´", "ê³¼"),
    "å±¥": ("ì‹ ", "ë¦¬"),
    "æ": ("ì˜¤ì–", "ì´"),
    "å† ": ("ê°“", "ê´€"),
    "è¢–": ("ì†Œë§¤", "ìˆ˜"),
    "æ‰‹": ("ì†", "ìˆ˜"),
    "å‚": ("ì˜†", "ë°©"),
    "è§€": ("ë³¼", "ê´€"),
    "ç®¡": ("ëŒ€ë¡±", "ê´€"),
    "é®‘": ("ì ˆì¸ ë¬¼ê³ ê¸°", "í¬"),
    "äº¤": ("ì‚¬ê·ˆ", "êµ"),
    "è˜­": ("ë‚œì´ˆ", "ë€"),
    "æ¼†": ("ì˜»", "ì¹ "),
    "ä¼¯": ("ë§", "ë°±"),
    "ç‰™": ("ì–´ê¸ˆë‹ˆ", "ì•„"),
    "çµƒ": ("ì¤„", "í˜„"),
    "åˆ": ("ëª©ë²¨", "ë¬¸"),
    "é ¸": ("ëª©", "ê²½"),
    "é": ("ì§€ë‚ ", "ê³¼"),
    "çŒ¶": ("ê°™ì„", "ìœ "),
    "åŠ": ("ë¯¸ì¹ ", "ê¸‰"),
    "æ™‚": ("ë•Œ", "ì‹œ"),
    "æ¡ƒ": ("ë³µìˆ­ì•„ë‚˜ë¬´", "ë„"),
    "åœ’": ("ë™ì‚°", "ì›"),
    "å¸¸": ("í•­ìƒ", "ìƒ"),
    "é‚¯": ("ë•…ì´ë¦„", "í•œ"),
    "é„²": ("ì¡°ë‚˜ë¼ì„œìš¸", "ë‹¨"),
    "æŸ¯": ("ê°€ì§€", "ê°€"),
    "èƒ¡": ("ë‚˜ë¹„", "í˜¸"),
    "è¶": ("ë‚˜ë¹„", "ì ‘"),
    "å¡": ("ë³€ë°©", "ìƒˆ"),
    "ç¿": ("ëŠ™ì€ì´", "ì˜¹"),
    "ç”¨": ("ì“¸", "ìš©"),
    "æ„": ("ëœ»", "ì˜"),
    "å‘¨": ("ë‘ë£¨", "ì£¼"),
    "åˆ°": ("ì´ë¥¼", "ë„"),
    "å­¤": ("ì™¸ë¡œìš¸", "ê³ "),
    "å¥®": ("ë–¨ì¹ ", "ë¶„"),
    "äº”": ("ë‹¤ì„¯", "ì˜¤"),
    "å¤š": ("ë§ì„", "ë‹¤"),
    "è‹¦": ("ê´´ë¡œìš¸", "ê³ "),
    "å„": ("ê°ê°", "ê°"),
    "åœ–": ("ê¾€í•˜ë‹¤", "ë„"),
    "è«": ("ì—†ì„", "ë§‰"),
    "é€†": ("ê±°ìŠ¤ë¥¼", "ì—­"),
    "å¯¦": ("ì—´ë§¤, ì‹¤ì œ", "ì‹¤"),
    "ç›¸": ("ì„œë¡œ", "ìƒ"),
    "ç¬¦": ("ë¶€í•©í• ", "ë¶€"),
    "è¾­": ("ë§ì”€", "ì‚¬"),
    "å¥": ("ê¸€ê·€", "êµ¬"),
    "å‰": ("ì•", "ì „"),
    "ä»£": ("ì‹œëŒ€", "ëŒ€"),
    "æœª": ("ì•„ë‹", "ë¯¸"),
    "æ›¾": ("ì¼ì°", "ì¦"),
    "ä½³": ("ì•„ë¦„ë‹¤ìš¸", "ê°€"),
    "ç´„": ("ì•½ì†, ë§ºì„", "ì•½"),
    "å–œ": ("ê¸°ì ", "í¬"),
    "å†": ("ë‘ ë²ˆ", "ì¬"),
    "æ­¸": ("ëŒì•„ê°ˆ", "ê·€"),
    "å§»": ("í˜¼ì¸", "ì¸"),
    "æ•¸": ("ì„¸ë‹¤", "ìˆ˜"),
    # ì¶”ê°€ í•œìë“¤
    "äºº": ("ì‚¬ëŒ", "ì¸"),
    "ç„¡": ("ì—†ì„", "ë¬´"),
    "ä¸‰": ("ì…‹", "ì‚¼"),
    "æ°´": ("ë¬¼", "ìˆ˜"),
    "å±±": ("ë«¼", "ì‚°"),
    "é¦¬": ("ë§", "ë§ˆ"),
    "å¤ª": ("í´", "íƒœ"),
    "é·„": ("ë‹­", "ê³„"),
    "éª¨": ("ë¼ˆ", "ê³¨"),
    "ä¸‹": ("ì•„ë˜", "í•˜"),
    "å‹": ("ì´ê¸¸", "ìŠ¹"),
    "è°": ("ì´ëª…í• ", "ì´"),
    "ç”²": ("ê°‘ì˜·", "ê°‘"),
    "å«": ("ë¨¸ê¸ˆì„", "í•¨"),
    "å¾": ("ë”°ë¥¼", "ì¢…"),
    "è›™": ("ê°œêµ¬ë¦¬", "ì™€"),
    "è¦‹": ("ë³¼", "ê²¬"),
    "å¦‚": ("ê°™ì„", "ì—¬"),
    "çŸ³": ("ëŒ", "ì„"),
    "åŒ…": ("ìŒ€", "í¬"),
    "å¤§": ("í´", "ëŒ€"),
    "å•†": ("ì¥ì‚¬", "ìƒ"),
    "æ³¥": ("ì§„í™", "ë‹ˆ"),
    "ç”°": ("ë°­", "ì „"),
    "é¬ª": ("ì‹¸ìš¸", "íˆ¬"),
    "ç‹—": ("ê°œ", "êµ¬"),
    "ç¢§": ("í‘¸ë¥¼", "ë²½"),
    "æ˜Œ": ("ì°½ì„±í• ", "ì°½"),
    "ç‰›": ("ì†Œ", "ìš°"),
    "äº‚": ("ì–´ì§€ëŸ¬ìš¸", "ë€"),
    "å ´": ("ë§ˆë‹¹", "ì¥"),
    "æœ": ("ë§‰ì„", "ë‘"),
    "é–€": ("ë¬¸", "ë¬¸"),
    "ä¸": ("ì•„ë‹", "ë¶ˆ"),
    "å‡º": ("ë‚ ", "ì¶œ"),
    "å¾": ("ì¹ ", "ì •"),
    "æ˜": ("ë°ì„", "ëª…"),
    "å‡": ("ë¹Œë¦´", "ê°€"),
    "é“": ("ê¸¸", "ë„"),
    "èµ°": ("ë‹¬ë¦´", "ì£¼"),
    "è‚–": ("ë‹®ì„", "ì´ˆ"),
    "çˆ²": ("ë ", "ìœ„"),
    "ç‹": ("ì„ê¸ˆ", "ì™•"),
    "æŒ": ("ê°€ì§ˆ", "ì§€"),
    "æ–§": ("ë„ë¼", "ë¶€"),
    "ä¸Š": ("ìœ„", "ìƒ"),
    "ç–": ("ì„±ê¸¸", "ì†Œ"),
    "æ·¸": ("ë§‘ì„", "ì²­"),
    "ç™½": ("í°", "ë°±"),
    "å": ("ê´€ë¦¬", "ë¦¬"),
    "èˆˆ": ("ì¼ìœ¼í‚¬", "í¥"),
    "äº¡": ("ë§í• ", "ë§"),
    "æ«Ÿ": ("ìƒìˆ˜ë¦¬ë‚˜ë¬´", "ì—­"),
    "æœ¨": ("ë‚˜ë¬´", "ëª©"),
    "æ§": ("ë§ˆë¥¼", "ê³ "),
    "åˆ»": ("ìƒˆê¸¸", "ê°"),
    "èˆŸ": ("ë°°", "ì£¼"),
    "æ±‚": ("êµ¬í• ", "êµ¬"),
    "åŠ": ("ì¹¼", "ê²€"),
    "æ ª": ("ê·¸ë£¨í„°ê¸°", "ì£¼"),
    "å¾…": ("ê¸°ë‹¤ë¦´", "ëŒ€"),
    "å…": ("í† ë¼", "í† "),
    "è† ": ("ì•„êµ", "êµ"),
    "æŸ±": ("ê¸°ë‘¥", "ì£¼"),
    "é¼“": ("ë¶", "ê³ "),
    "ç‘Ÿ": ("ê±°ë¬¸ê³ ", "ìŠ¬"),
    "å°¾": ("ê¼¬ë¦¬", "ë¯¸"),
    "ç”Ÿ": ("ë‚ ", "ìƒ"),
    "ä¹‹": ("~ì˜", "ì§€"),
    "ä¿¡": ("ë¯¿ì„", "ì‹ "),
    "ä¸": ("ì•„ë‹", "ë¶ˆ"),
    "é£Ÿ": ("ë¨¹ì„", "ì‹"),
    "è¨€": ("ë§ì”€", "ì–¸"),
    "ä½©": ("ì°°", "íŒ¨"),
    "éˆ´": ("ë°©ìš¸", "ë ¹"),
    "è‡ª": ("ìŠ¤ìŠ¤ë¡œ", "ì"),
    "æˆ’": ("ê²½ê³„í• ", "ê³„"),
    "æ¾": ("ì†Œë‚˜ë¬´", "ì†¡"),
    "éƒ½": ("ë„ì", "ë„"),
    "å¥‘": ("ê³„ì•½", "ê³„"),
    "å“¡": ("ì›", "ì›"),
    "æœˆ": ("ë‹¬", "ì›”"),
    "æ²™": ("ëª¨ë˜", "ì‚¬"),
    "å¤«": ("ì§€ì•„ë¹„", "ë¶€"),
    "äºº": ("ì‚¬ëŒ", "ì¸"),
    "é‡": ("ë“¤", "ì•¼"),
    "é¼ ": ("ì¥", "ì„œ"),
    "å©š": ("í˜¼ì¸", "í˜¼"),
    "å¤«": ("ì§€ì•„ë¹„", "ë¶€"),
    "å¦»": ("ì•„ë‚´", "ì²˜"),
    "è©µ": ("í¼", "ìŠ¹"),
    "é¡": ("ê±°ìš¸", "ê²½"),
    "é«˜": ("ë†’ì„", "ê³ "),
    "éº—": ("ê³ ìš¸", "ë ¤"),
    "å…¬": ("ê³µë³€ë ", "ê³µ"),
    "äº‹": ("ì¼", "ì‚¬"),
    "ä¸‰": ("ì…‹", "ì‚¼"),
    "æ—¥": ("ë‚ ", "ì¼"),
    "æ„¾": ("ë¶„ê°œí• ", "ê°œ"),
    "å±±": ("ë«¼", "ì‚°"),
    "å¯ƒ": ("ì›í†µí• ", "ì›"),
    "ç‰›": ("ì†Œ", "ìš°"),
    "éŒ¦": ("ë¹„ë‹¨", "ê¸ˆ"),
    "ç¹¡": ("ìˆ˜ë†“ì„", "ìˆ˜"),
    "æ±Ÿ": ("ê°•", "ê°•"),
    "å±±": ("ë«¼", "ì‚°"),
    "å…„": ("í˜•", "í˜•"),
    "å‹": ("ë²—", "ìš°"),
    "å¼Ÿ": ("ì•„ìš°", "ì œ"),
    "æ­": ("ê³µì†í• ", "ê³µ"),
    "å—": ("ë‚¨ë…˜", "ë‚¨"),
    "å¤§": ("í´", "ëŒ€"),
    "é–€": ("ë¬¸", "ë¬¸"),
    "å…¥": ("ë“¤", "ì…"),
    "ç´": ("ë“¤ì¼", "ë‚©"),
    "åš": ("ë„“ì„", "ë°•"),
    "å­¸": ("ë°°ìš¸", "í•™"),
    "å¯©": ("ìì„¸íˆ", "ì‹¬"),
    "å•": ("ë¬»ë‹¤", "ë¬¸"),
    "éŸ‹": ("ê°€ì£½", "ìœ„"),
    "ç·¨": ("ì—®ì„", "í¸"),
    "ä¸‰": ("ì…‹", "ì‚¼"),
    "çµ¶": ("ëŠì„", "ì ˆ"),
    "ç™¼": ("ì ", "ë°œ"),
    "æ†¤": ("ë¶„í• ", "ë¶„"),
    "å¿˜": ("ìŠì„", "ë§"),
    "é£Ÿ": ("ë¨¹ì„", "ì‹"),
    "è‡ª": ("ìŠ¤ìŠ¤ë¡œ", "ì"),
    "å¼º": ("ê°•í• ", "ê°•"),
    "ä¸": ("ì•„ë‹", "ë¶ˆ"),
    "æ¯": ("ì‰´", "ì‹"),
    "è¢": ("ë°˜ë”§ë¶ˆ", "í˜•"),
    "é›ª": ("ëˆˆ", "ì„¤"),
    "ä¹‹": ("~ì˜", "ì§€"),
    "åŠŸ": ("ê³µ", "ê³µ"),
    "æ‰‹": ("ì†", "ìˆ˜"),
    "ä¸": ("ì•„ë‹", "ë¶ˆ"),
    "é‡‹": ("ë†“ì„", "ì„"),
    "å·": ("ê¶Œ", "ê¶Œ")
}

# ì—‘ì…€ì—ì„œ ê°€ì ¸ì˜¨ ì‚¬ìì„±ì–´ ë°ì´í„° (ê²‰ëœ»ê³¼ ì†ëœ» êµ¬ë¶„)
IDIOM_DATA = {
    "æ³•å¤å‰µæ–°": {
        "korean": "ë²•ê³ ì°½ì‹ ",
        "outer_meaning": "ì˜›ê²ƒì„ ë³¸ë°›ì•„ ìƒˆë¡œìš´ê²ƒì„ ì°½ì¡°í•œë‹¤",
        "inner_meaning": "ì˜›ê²ƒì— í† ëŒ€ë¥¼ ë‘ë˜ ê·¸ê²ƒì„ ë³€í™”ì‹œí‚¨ì¤„ ì•Œê³  ìƒˆê²ƒì„ ë§Œë“¤ì–´ ê°€ë˜ ê·¼ë³¸ì„ ìƒì§€ ë§ì•„ì•¼í•œë‹¤"
    },
    "ä¸‰æ°´ç”²å±±": {
        "korean": "ì‚¼ìˆ˜ê°‘ì‚°",
        "outer_meaning": "í•¨ê²½ë„ì˜ ì‚¼ìˆ˜ì™€ ê°‘ì‚°",
        "inner_meaning": "ë§¤ìš° í˜ë“¤ê³  í—˜ë‚œí•œ ê³³ìœ¼ë¡œ ê°€ê±°ë‚˜ ì–´ë ¤ìš´ ì§€ê²½ì— ì´ë¦„"
    },
    "ä¸‰é¦¬å¤ªå®ˆ": {
        "korean": "ì‚¼ë§ˆíƒœìˆ˜",
        "outer_meaning": "ì„¸ë§ˆë¦¬ì˜ ë§ë§Œ íƒ€ê³  í–‰ì°¨í•˜ëŠ” ìˆ˜ë ¹",
        "inner_meaning": "ì—¬ëŸ¬ ì‚¬ëŒì´ í•œ ìë¦¬ë¥¼ ë†“ê³  ë‹¤íˆ¼"
    },
    "é·„åµæœ‰éª¨": {
        "korean": "ê³„ê°„ìœ ê³¨",
        "outer_meaning": "ë‹¬ê±€ì´ ê³¯ì•˜ë‹¤",
        "inner_meaning": "ìš´ìˆ˜ê°€ ë‚˜ìœ ì‚¬ëŒì€ ëª¨ì²˜ëŸ¼ ì¢‹ì€ ê¸°íšŒë¥¼ ë§Œë‚˜ë„ ì—­ì‹œ ì¼ì´ ì˜ ì•ˆë¨"
    },
    "ä¸è¨€é•·çŸ­": {
        "korean": "ë¶ˆì–¸ì¥ë‹¨",
        "outer_meaning": "ë‚¨ì˜ ì¥ë‹¨ì ì„ ë§í•˜ì§€ ì•ŠëŠ”ë‹¤",
        "inner_meaning": "í™©í¬ì •ìŠ¹ê³¼ ë†ë¶€ì˜ ëŒ€í™”ì—ì„œ ìœ ë˜"
    },
    "ä¸‹é¦¬è©•": {
        "korean": "í•˜ë§ˆí‰",
        "outer_meaning": "ë§ì—ì„œ ë‚´ë¦° ë’¤ì˜ í‰ê°€",
        "inner_meaning": "ê´€ì§ì˜ ì¸ì‚¬ì´ë™ì´ë‚˜ ê´€ì§ì— ì„ëª…ë  í›„ë³´ìì— ëŒ€í•œ í’ë¬¸"
    },
    "è½é»": {
        "korean": "ë‚™ì ",
        "outer_meaning": "ì ì„ ì°ë‹¤",
        "inner_meaning": "ì—¬ëŸ¬ í›„ë³´ê°€ ìˆì„ëŒ€ ê·¸ì¤‘ ë§ˆë•…í•œ ëŒ€ìƒì„ ê³ ë¦„"
    },
    "éˆç­†å‹è°": {
        "korean": "ë‘”í•„ìŠ¹ì´",
        "outer_meaning": "ë¬´ë”˜ ë¶“ì´ ì´ëª…í•¨ë³´ë‹¤ ë‚«ë‹¤",
        "inner_meaning": "ì„œíˆ° ê¸€ì´ë¼ë„ ê¸°ë¡í•˜ëŠ”ê²ƒì´ ê¸°ì–µë³´ë‹¤ ë‚«ë‹¤"
    },
    "å€Ÿé·„é¨é‚„": {
        "korean": "ì°¨ê³„ê¸°í™˜",
        "outer_meaning": "ë‹­ì„ ë¹Œë ¤ íƒ€ê³  ë“¤ì–´ê°„ë‹¤",
        "inner_meaning": "ì†ë‹˜ì„ ë°•ëŒ€í•˜ëŠ” ê²ƒì„ ë¹—ëŒ€ì–´ ì´ë¥´ëŠ” ë§"
    },
    "å‹ç”²ç›œè³Š": {
        "korean": "ìŠ¬ê°‘ë„ì ",
        "outer_meaning": "ìŠ¬ê°‘(ë°©í•œêµ¬-ë¬´ë¦ê°€ë¦¬ê°œ)ì„ ë¨¸ë¦¬ì— ì“´ ë„ì ",
        "inner_meaning": "ë‚¨ì˜ ê¸€ì´ë‚˜ ì €ìˆ ì„ ë² ê»´ ë§ˆì¹˜ ì œê°€ ì§€ì€ ê²ƒì²˜ëŸ¼ í•˜ëŠ” ì‚¬ëŒ"
    },
    "å«äººå¾è›™": {
        "korean": "ì‚¬ì¸ì¢…ì™€",
        "outer_meaning": "ê°œêµ¬ë¦¬ë¥¼ ì‚¼í‚¨ ì‚¬ëŒì´ ê°œêµ¬ë¦¬ë¥¼ ë”°ë¥¸ë‹¤",
        "inner_meaning": "ìœ„ê¸ˆ ìƒí™©ì— ê¸°ì§€ë¥¼ ë°œíœ˜í•˜ì—¬ ëŒ€ì²˜í•¨"
    },
    "å¼˜ç›Šäººé–“": {
        "korean": "í™ìµì¸ê°„",
        "outer_meaning": "ë„ë¦¬ ì¸ê°„ì„ ì´ë¡­ê²Œ í•œë‹¤",
        "inner_meaning": "í™ìµì¸ê°„ ì‚¬ìƒì˜ ê·¼ë³¸ ì´ë…"
    },
    "è¦‹é‡‘å¦‚çŸ³": {
        "korean": "ê²¬ê¸ˆì—¬ì„",
        "outer_meaning": "í™©ê¸ˆì„ ëŒê°™ì´ ë³¸ë‹¤",
        "inner_meaning": "ì§€ë‚˜ì¹œ ìš•ì‹¬ì„ ì ˆì œí•¨"
    },
    "å…«åŒ…å¤§å•†": {
        "korean": "íŒ”í¬ëŒ€ìƒ",
        "outer_meaning": "ì—¬ëŸ ìë£¨ì˜ ì§ì„ ê°€ì§„ í° ìƒì¸",
        "inner_meaning": "ìƒí™œì— ê±±ì •ì´ ì—†ëŠ” ì‚¬ëŒ"
    },
    "æ³¥ç”°é¬ªç‹—": {
        "korean": "ì´ì „íˆ¬êµ¬",
        "outer_meaning": "ì§„í™ë°­ì—ì„œ ê°œê°€ ì‹¸ìš´ë‹¤",
        "inner_meaning": "ìê¸° ì´ìµì„ ìœ„í•˜ì—¬ ë¶ˆì½ì‚¬ë‚©ê²Œ ì‹¸ì›€"
    },
    "ç¢§æ˜Œç‰›": {
        "korean": "ë²½ì°½ìš°",
        "outer_meaning": "í‘¸ë¥¸ ì°½ê°€ì˜ ì†Œ",
        "inner_meaning": "ë¯¸ë ¨í•˜ê³  ê³ ì§‘ì´ ì„¼ ì‚¬ëŒ"
    },
    "äº‚å ´": {
        "korean": "ë‚œì¥",
        "outer_meaning": "ì–´ì§€ëŸ¬ìš´ ë§ˆë‹¹",
        "inner_meaning": "ì—¬ëŸ¬ ì‚¬ëŒì´ ì–´ì§€ëŸ¬ì´ ë’¤ì„ì—¬ ë– ë“¤ì–´ëŒ€ê±°ë‚˜ ë’¤ì—‰ì¼œ ë’¤ì£½ë°•ì£½ì´ ëœ ê³³"
    },
    "æœé–€ä¸å‡º": {
        "korean": "ë‘ë¬¸ë¶ˆì¶œ",
        "outer_meaning": "ë¬¸ì„ ë§‰ê³  ë‚˜ê°€ì§€ ì•ŠëŠ”ë‹¤",
        "inner_meaning": "ì§‘ì—ì„œ ì€ê±°í•˜ë©´ì„œ ê´€ì§ì— ë‚˜ê°€ì§€ ì•„ë‹ˆí•˜ê±°ë‚˜ ì‚¬íšŒì˜ ì¼ì„ í•˜ì§€ ì•„ë‹ˆí•¨"
    },
    "å¾æ˜å‡é“": {
        "korean": "ì •ëª…ê°€ë„",
        "outer_meaning": "ëª…ë‚˜ë¼ë¥¼ ì¹˜ê¸° ìœ„í•´ ê¸¸ì„ ë¹Œë¦°ë‹¤",
        "inner_meaning": "ì–´ë–¤ ì¼ì„ ì´ë£¨ê¸° ìœ„í•´ ë§ë„ ì•ˆë˜ëŠ” ëª…ë¶„ì„ ë‚´ì„¸ì›€"
    },
    "èµ°è‚–çˆ²ç‹": {
        "korean": "ì£¼ì´ˆìœ„ì™•",
        "outer_meaning": "ë‹¬ë ¤ê°€ì„œ ë‹®ì€ ìë¥¼ ì™•ìœ¼ë¡œ ì„¸ìš´ë‹¤",
        "inner_meaning": "ì •ì ì„ ì—†ì• ê¸° ìœ„í•´ ê°–ì€ ìˆ ìˆ˜ë¥¼ ì”€"
    },
    "æŒæ–§ä¸Šç–": {
        "korean": "ì§€ìˆ˜ìƒì†Œ",
        "outer_meaning": "ë„ë¼ë¥¼ ë“¤ê³  ìƒì†Œë¥¼ ì˜¬ë¦°ë‹¤",
        "inner_meaning": "ì™•ì˜ ì‹¤ì •ì— ëŒ€í•´ ëª©ìˆ¨ì„ ê±¸ê³  ì§€ì í•˜ëŠ” ì‹ í•˜ì˜ ê¸°ê°œ"
    },
    "æ·¸ç™½å": {
        "korean": "ì²­ë°±ë¦¬",
        "outer_meaning": "ê¹¨ë—í•˜ê³  í° ê´€ë¦¬",
        "inner_meaning": "ì²­ë ´í•˜ê³  ê²°ë°±í•œ ê´€ë¦¬"
    },
    "èˆˆæ·¸äº¡æ·¸": {
        "korean": "í¥ì²­ë§ì²­",
        "outer_meaning": "í¥ì²­ê±°ë¦¬ë©° ë§ì²­ê±°ë¦°ë‹¤",
        "inner_meaning": "ëˆì´ë‚˜ ë¬¼ê±´ì„ í•¨ë¶€ë¡œ ì“°ë©° ë§ˆìŒê» ì¦ê¸°ëŠ” ëª¨ì–‘"
    },
    "æ«Ÿæœ¨æ§": {
        "korean": "ë…¸ëª©ê³„",
        "outer_meaning": "ìƒìˆ˜ë¦¬ë‚˜ë¬´ê°€ ë§ˆë¥¸ë‹¤",
        "inner_meaning": "ì¡°ê¸ˆë„ ìœµí†µì„±ì´ ì—†ëŠ” ë¯¸ë ¨í•œ ì‚¬ëŒ"
    },
    "åˆ»èˆŸæ±‚åŠ": {
        "korean": "ê°ì£¼êµ¬ê²€",
        "outer_meaning": "ë°°ì— ìƒˆê²¨ì„œ ì¹¼ì„ êµ¬í•œë‹¤",
        "inner_meaning": "ì–´ë¦¬ì„ê³  ë¯¸ë ¨í•˜ì—¬ ìœµí†µì„±ì´ ì—†ìŒ"
    },
    "å®ˆæ ªå¾…å…”": {
        "korean": "ìˆ˜ì£¼ëŒ€í† ",
        "outer_meaning": "ê·¸ë£¨í„°ê¸°ë¥¼ ì§€í‚¤ë©° í† ë¼ë¥¼ ê¸°ë‹¤ë¦°ë‹¤",
        "inner_meaning": "ìš”í–‰ìœ¼ë¡œ ì¼ì´ ì„±ì·¨ë˜ê¸°ë¥¼ ë°”ë¼ê±°ë‚˜ ì–´ë–¤ ì°©ê°ì— ë¹ ì ¸ ë˜ì§€ë„ ì•Šì„ ì¼ì„ ê³µì—°íˆ ê³ ì§‘í•˜ëŠ” ì–´ë¦¬ì„ìŒ"
    },
    "è† æŸ±é¼“ç‘Ÿ": {
        "korean": "êµì£¼ê³ ìŠ¬",
        "outer_meaning": "ì•„êµë¡œ ê¸°ë‘¥ì„ ë¶™ì—¬ ê±°ë¬¸ê³ ë¥¼ ì¹œë‹¤",
        "inner_meaning": "ê³ ì§€ì‹í•˜ì—¬ ìœµí†µì„±ì´ ì „í˜€ ì—†ìŒ"
    },
    "å°¾ç”Ÿä¹‹ä¿¡": {
        "korean": "ë¯¸ìƒì§€ì‹ ",
        "outer_meaning": "ë¯¸ìƒì˜ ì‹ ì˜",
        "inner_meaning": "ê³ ì§€ì‹í•˜ì—¬ ìœµí†µì„±ì´ ì „í˜€ ì—†ìŒ"
    },
    "ç‹ä¸é£Ÿè¨€": {
        "korean": "ì™•ë¶ˆì‹ì–¸",
        "outer_meaning": "ì™•ì€ ë§ì„ ë¨¹ì§€ ì•ŠëŠ”ë‹¤",
        "inner_meaning": "í•¨ë¶€ë¡œ ê±°ì§“ë§ì´ë‚˜ ë¹ˆë§ì„ í•´ì„  ì•ˆë¨"
    },
    "ä½©éˆ´è‡ªæˆ’": {
        "korean": "íŒ¨ë ¹ìê³„",
        "outer_meaning": "ë°©ìš¸ì„ ì°¨ê³  ìŠ¤ìŠ¤ë¡œ ê²½ê³„í•œë‹¤",
        "inner_meaning": "ë‚˜ìœ ìŠµê´€ì´ë‚˜ ë‹¨ì ì„ ê³ ì¹˜ê¸° ìœ„í•´ ìŠ¤ìŠ¤ë¡œ ë…¸ë ¥í•˜ëŠ” ìì„¸"
    },
    "æ¾éƒ½å¥‘å“¡": {
        "korean": "ì†¡ë„ê³„ì›",
        "outer_meaning": "ì†¡ë„ì˜ ê³„ì›",
        "inner_meaning": "í•˜ì°®ì€ ì§€ìœ„ë‚˜ ì„¸ë ¥ì„ ë¯¿ê³  ë‚¨ì„ ë©¸ì‹œí•˜ê³  ì˜¤ë§Œí•˜ê²Œ êµ¬ëŠ” ì‚¬ëŒ"
    },
    "æœˆæ²™å¤«äºº": {
        "korean": "ì›”ì‚¬ë¶€ì¸",
        "outer_meaning": "ë‹¬ë¹› ëª¨ë˜ì˜ ë¶€ì¸",
        "inner_meaning": "ë‚¨í¸ì˜ ì§€ìœ„ê°€ ë†’ì€ë°ë„ ê²€ì†Œí•˜ì—¬ íƒ€ì˜ ëª¨ë²”ì´ ë˜ëŠ” ë¶€ì¸"
    },
    "é‡é¼ å©š": {
        "korean": "ì•¼ì„œí˜¼",
        "outer_meaning": "ë“¤ì¥ì˜ í˜¼ì¸",
        "inner_meaning": "ì œ ë¶„ìˆ˜ì— ë„˜ì¹˜ëŠ” í—ˆì˜ì‹¬. ë™ë¥˜ëŠ” ë™ë¥˜ë¼ë¦¬ ê°€ì¥ ì˜ ì–´ìš¸ë¦¼"
    },
    "å¤«å¦»è©µé¡": {
        "korean": "ë¶€ì²˜ìŠ¹ê²½",
        "outer_meaning": "ë¶€ë¶€ê°€ ê±°ìš¸ì„ í¼ì¹œë‹¤",
        "inner_meaning": "ê°€ìƒê³¼ ì‹¤ìƒì˜ í˜¼ë€ì— ë¹ ì§„ ì¡´ì¬ì˜ ì–´ë¦¬ì„ìŒ"
    },
    "é«˜éº—å…¬äº‹ä¸‰æ—¥": {
        "korean": "ê³ ë ¤ê³µì‚¬ì‚¼ì¼",
        "outer_meaning": "ê³ ë ¤ì˜ ê³µì‚¬ëŠ” ì‚¼ì¼",
        "inner_meaning": "í•œë²ˆ ì‹œì‘í•œ ì¼ì´ ì˜¤ë˜ ê³„ì†ë˜ì–´ ê°€ì§€ ëª»í•¨"
    },
    "æ„¾å±±å¯ƒç‰›": {
        "korean": "ì¾Œì‚°ì›ìš°",
        "outer_meaning": "ì‚°ì— ë¶„ê°œí•˜ê³  ì†Œë¥¼ ì›ë§í•œë‹¤",
        "inner_meaning": "ì¶©ì„±ì„ ë°”ì³¤ìœ¼ë‚˜ ë„ë¦¬ì–´ ì£½ìŒì„ ë§ì´í•¨"
    },
    "éŒ¦ç¹¡æ±Ÿå±±": {
        "korean": "ê¸ˆìˆ˜ê°•ì‚°",
        "outer_meaning": "ë¹„ë‹¨ìœ¼ë¡œ ìˆ˜ë†“ì€ ê°•ì‚°",
        "inner_meaning": "ìš°ë¦¬ë‚˜ë¼ì˜ ì‚°ì²œì„ ë¹„ìœ ì ìœ¼ë¡œ ì´ë¥´ëŠ” ë§"
    },
    "å…„å‹å¼Ÿæ­": {
        "korean": "í˜•ìš°ì œê³µ",
        "outer_meaning": "í˜•ì€ ìš°ì• í•˜ê³  ì•„ìš°ëŠ” ê³µì†í•˜ë‹¤",
        "inner_meaning": "í˜•ì œê°„ì— ì„œë¡œ ìš°ì•  ê¹Šê²Œ ì§€ëƒ„"
    },
    "å—å¤§é–€å…¥ç´": {
        "korean": "ë‚¨ëŒ€ë¬¸ì…ë‚©",
        "outer_meaning": "ë‚¨ëŒ€ë¬¸ìœ¼ë¡œ ë“¤ì–´ê°€ ë‚©ë¶€í•œë‹¤",
        "inner_meaning": "ì¤„ê±°ë¦¬ë‚˜ ê³¨ìë¥¼ ì•Œ ìˆ˜ ì—†ëŠ” ë§ì„ ë¹„ìœ ì ìœ¼ë¡œ ì´ë¥´ëŠ” ë§"
    },
    "åšå­¸å¯©å•": {
        "korean": "ë°•í•™ì‹¬ë¬¸",
        "outer_meaning": "ë„“ê²Œ ë°°ìš°ê³  ìì„¸íˆ ë¬»ëŠ”ë‹¤",
        "inner_meaning": "í•™ë¬¸ì„ í•˜ëŠ” ì˜¬ë°”ë¥¸ ìì„¸"
    },
    "éŸ‹ç·¨ä¸‰çµ¶": {
        "korean": "ìœ„í¸ì‚¼ì ˆ",
        "outer_meaning": "ê°€ì£½ëˆì´ ì„¸ ë²ˆ ëŠì–´ì§„ë‹¤",
        "inner_meaning": "ì±…ì„ ì—´ì‹¬íˆ ì½ìŒ, ë¶€ì§€ëŸ°íˆ ë°°ìš°ë‹¤, í•™ë¬¸ì— í˜ì”€"
    },
    "ç™¼æ†¤å¿˜é£Ÿ": {
        "korean": "ë°œë¶„ë§ì‹",
        "outer_meaning": "ë¶„ë°œí•˜ì—¬ ì‹ì‚¬ë¥¼ ìŠëŠ”ë‹¤",
        "inner_meaning": "ë¼ë‹ˆê¹Œì§€ë„ ìŠì„ ì •ë„ë¡œ ì–´ë–¤ì¼ì— ì—´ì¤‘í•˜ì—¬ ë…¸ë ¥í•¨"
    },
    "è‡ªå¼ºä¸æ¯": {
        "korean": "ìê°•ë¶ˆì‹",
        "outer_meaning": "ìŠ¤ìŠ¤ë¡œ ê°•í•´ì§€ê¸°ë¥¼ ì‰¬ì§€ ì•ŠëŠ”ë‹¤",
        "inner_meaning": "ìì‹ ì˜ ëª©í‘œë¥¼ í–¥í•´ ëŠì„ ì—†ì´ ë…¸ë ¥í•˜ëŠ”ê²ƒ"
    },
    "è¢é›ªä¹‹åŠŸ": {
        "korean": "í˜•ì„¤ì§€ê³µ",
        "outer_meaning": "ë°˜ë”§ë¶ˆê³¼ ëˆˆì˜ ê³µ",
        "inner_meaning": "ì–´ë ¤ìš´ í™˜ê²½ì—ì„œë„ ë¶€ì§€ëŸ°í•˜ê³  ê¾¸ì¤€í•˜ê²Œ ê³µë¶€í•˜ì—¬ ì„±ê³µí•¨"
    },
    "æ‰‹ä¸é‡‹å·": {
        "korean": "ìˆ˜ë¶ˆì„ê¶Œ",
        "outer_meaning": "ì†ì—ì„œ ì±…ì„ ë†“ì§€ ì•ŠëŠ”ë‹¤",
        "inner_meaning": "í•­ìƒ ì†ì— ì±…ì„ ë“¤ê³  ê¸€ì„ ì½ìœ¼ë©´ì„œ ê³µë¶€í•¨"
    },
    "äººç”Ÿç„¡å¸¸": {
        "korean": "ì¸ìƒë¬´ìƒ",
        "outer_meaning": "ì‚¬ëŒì˜ ì¸ìƒì´ ë¬´ìƒí•˜ë‹¤",
        "inner_meaning": "ì‚¬ëŒì˜ ì¼ìƒì´ ë§ì—†ì´ í˜ëŸ¬ê°"
    },
    "æ¡‚æ—ä¸€æ": {
        "korean": "ê³„ë¦¼ì¼ì§€",
        "outer_meaning": "ê³„ìˆ˜ë‚˜ë¬´ ìˆ²ì˜ í•œ ê°€ì§€",
        "inner_meaning": "ì‚¬ëŒë¨ì´ ë¹„ë²”í•˜ë©´ì„œ ê²¸ì†í•¨"
    },
    "å¤–æŸ”å…§å‰›": {
        "korean": "ì™¸ìœ ë‚´ê°•",
        "outer_meaning": "ê²‰ì€ ë¶€ë“œëŸ½ê³  ì†ì€ êµ³ì„¸ë‹¤",
        "inner_meaning": "ê²‰ìœ¼ë¡œëŠ” ë¶€ë“œëŸ½ê³  ìˆœí•˜ë‚˜ ì†ì€ ê³§ê³  ê¿‹ê¿‹í•¨"
    },
    "ç¦®ç¾©å»‰æ¥": {
        "korean": "ì˜ˆì˜ì—¼ì¹˜",
        "outer_meaning": "ì˜ˆì ˆê³¼ ì˜ë¦¬ì™€ ì²­ë ´ê³¼ ë¶€ë„ëŸ¬ì›€",
        "inner_meaning": "ì˜ˆì ˆ, ì˜ë¦¬, ì²­ë ´, ë¶€ë„ëŸ¬ì›€ì„ ì•„ëŠ” íƒœë„"
    },
    "ä¸€å¿ƒåŒé«”": {
        "korean": "ì¼ì‹¬ë™ì²´",
        "outer_meaning": "í•œ ë§ˆìŒ ê°™ì€ ëª¸",
        "inner_meaning": "ë‘˜ ì´ìƒì˜ ì‚¬ëŒì´ êµ³ê²Œ ë­‰ì¹˜ëŠ” ì¼"
    },
    "ç•°å£åŒè²": {
        "korean": "ì´êµ¬ë™ì„±",
        "outer_meaning": "ë‹¤ë¥¸ ì…ìœ¼ë¡œ ê°™ì€ ì†Œë¦¬",
        "inner_meaning": "ì—¬ëŸ¬ ì‚¬ëŒì˜ ë§ì´ í•œê²°ê°™ìŒ"
    },
    "æ¸¾ç„¶ä¸€é«”": {
        "korean": "í˜¼ì—°ì¼ì²´",
        "outer_meaning": "ëª¨ë‘ í•˜ë‚˜ì˜ ëª¸",
        "inner_meaning": "ì¡°ê¸ˆì˜ ì–´ê¸‹ë‚¨ë„ ì—†ì´ í•œë©ì–´ë¦¬ê°€ ë¨"
    },
    "å¤§åŒåœ˜çµ": {
        "korean": "ëŒ€ë™ë‹¨ê²°",
        "outer_meaning": "í¬ê²Œ ê°™ì´ ë­‰ì¹œë‹¤",
        "inner_meaning": "ì—¬ëŸ¬ ì§‘ë‹¨ì´ë‚˜ ì‚¬ëŒì´ ì–´ë–¤ ëª©ì ì„ ì´ë£¨ë ¤ê³  í¬ê²Œ í•œ ë©ì–´ë¦¬ë¡œ ë­‰ì¹¨"
    },
    "åŒåºŠç•°å¤¢": {
        "korean": "ë™ìƒì´ëª½",
        "outer_meaning": "ê°™ì€ ì ìë¦¬ì—ì„œ ë‹¤ë¥¸ ê¿ˆ",
        "inner_meaning": "ê²‰ìœ¼ë¡œëŠ” ê°™ì´ í–‰ë™í•˜ë©´ì„œë„ ì†ìœ¼ë¡œëŠ” ê°ê° ë”´ìƒê°ì„ í•˜ê³  ìˆìŒ"
    },
    "å’¸èˆˆå·®ä½¿": {
        "korean": "í•¨í¥ì°¨ì‚¬",
        "outer_meaning": "í•¨í¥ìœ¼ë¡œ ê°„ ì°¨ì‚¬",
        "inner_meaning": "ì‹¬ë¶€ë¦„ì„ ê°„ ì‚¬ëŒì´ ì†Œì‹ì´ ì•„ì£¼ ì—†ê±°ë‚˜ ë˜ëŠ” íšŒë‹µì´ ì¢€ì²˜ëŸ¼ ì˜¤ì§€ ì•ŠìŒ"
    },
    "çƒé£›æ¢¨è½": {
        "korean": "ì˜¤ë¹„ì´ë½",
        "outer_meaning": "ê¹Œë§ˆê·€ê°€ ë‚ ê³  ë°°ê°€ ë–¨ì–´ì§„ë‹¤",
        "inner_meaning": "ìš°ì—°ì˜ ì¼ì¹˜ë¡œ ì˜ì‹¬ì„ ë°›ìŒ"
    },
    "è¢–æ‰‹å‚è§€": {
        "korean": "ìˆ˜ìˆ˜ë°©ê´€",
        "outer_meaning": "ì†Œë§¤ì— ì†ì„ ë„£ê³  ì˜†ì—ì„œ ë³¸ë‹¤",
        "inner_meaning": "íŒ”ì§±ì„ ë¼ê³  ë³´ê³ ë§Œ ìˆë‹¤"
    },
    "éçŒ¶ä¸åŠ": {
        "korean": "ê³¼ìœ ë¶ˆê¸‰",
        "outer_meaning": "ì§€ë‚˜ì¹¨ì€ ë¯¸ì¹˜ì§€ ëª»í•¨ê³¼ ê°™ë‹¤",
        "inner_meaning": "ì •ë„ë¥¼ ì§€ë‚˜ì¹¨ì€ ë¯¸ì¹˜ì§€ ëª»í•¨ê³¼ ê°™ë‹¤ëŠ” ëœ»"
    },
    "æ™‚æ™‚åˆ»åˆ»": {
        "korean": "ì‹œì‹œê°ê°",
        "outer_meaning": "ë•Œë•Œë¡œ ê°ê°",
        "inner_meaning": "ì‹œê°„ì´ íë¦„ì— ë”°ë¼"
    },
    "æ¡ƒåœ’çµç¾©": {
        "korean": "ë„ì›ê²°ì˜",
        "outer_meaning": "ë³µìˆ­ì•„ ë™ì‚°ì—ì„œ ì˜ë¥¼ ë§ºë‹¤",
        "inner_meaning": "ì˜í˜•ì œë¥¼ ë§ºìŒ. ì„œë¡œ ë‹¤ë¥¸ ì‚¬ëŒë“¤ì´ ì‚¬ìš•ì„ ë²„ë¦¬ê³  ëª©ì ì„ í–¥í•´ í•©ì‹¬í•  ê²ƒì„ ê²°ì˜í•¨"
    },
    "ç®¡é®‘ä¹‹äº¤": {
        "korean": "ê´€í¬ì§€êµ",
        "outer_meaning": "ê´€ì¤‘ê³¼ í¬ìˆ™ì˜ ì‚¬ê·",
        "inner_meaning": "ìš°ì •ì´ ì•„ì£¼ ëˆë…í•œ ì¹œêµ¬ ê´€ê³„"
    },
    "é‡‘è˜­ä¹‹äº¤": {
        "korean": "ê¸ˆë€ì§€êµ",
        "outer_meaning": "í™©ê¸ˆê³¼ ë‚œì´ˆì˜ ì‚¬ê·",
        "inner_meaning": "ì¹œêµ¬ ì‚¬ì´ì˜ ë§¤ìš° ë‘í„°ìš´ ì •"
    },
    "èŠè˜­ä¹‹äº¤": {
        "korean": "ì§€ë€ì§€êµ",
        "outer_meaning": "ì§€ì´ˆì™€ ë‚œì´ˆì˜ ì‚¬ê·",
        "inner_meaning": "ë²— ì‚¬ì´ì˜ ë§‘ê³ ë„ ê³ ê·€í•œ ì‚¬ê·"
    },
    "æ°´é­šä¹‹äº¤": {
        "korean": "ìˆ˜ì–´ì§€êµ",
        "outer_meaning": "ë¬¼ê³¼ ë¬¼ê³ ê¸°ì˜ ì‚¬ê·",
        "inner_meaning": "ë§¤ìš° ì¹œë°€í•˜ê²Œ ì‚¬ê·€ì–´ ë–¨ì–´ì§ˆ ìˆ˜ ì—†ëŠ” ì‚¬ì´"
    },
    "è† æ¼†ä¹‹äº¤": {
        "korean": "êµì¹ ì§€êµ",
        "outer_meaning": "ì•„êµì™€ ì˜»ì˜ ì‚¬ê·",
        "inner_meaning": "ì•„ì£¼ ì¹œë°€í•˜ì—¬ ì„œë¡œ ë–¨ì–´ì§€ì§€ ì•Šê³  ë§ˆìŒì´ ë³€í•˜ì§€ ì•ŠëŠ” ë‘í„°ìš´ ìš°ì •"
    },
    "ä¼¯ç‰™çµ¶çµƒ": {
        "korean": "ë°±ì•„ì ˆí˜„",
        "outer_meaning": "ë°±ì•„ê°€ ê±°ë¬¸ê³  ì¤„ì„ ëŠë‹¤",
        "inner_meaning": "ìê¸°ë¥¼ ì•Œì•„ì£¼ëŠ” ì ˆì¹œí•œ ë²—ì˜ ì£½ìŒì„ ìŠ¬í¼í•¨"
    },
    "åˆé ¸ä¹‹äº¤": {
        "korean": "ë¬¸ê²½ì§€êµ",
        "outer_meaning": "ëª©ì„ ë² ëŠ” ì‚¬ê·",
        "inner_meaning": "ìƒì‚¬ë¥¼ ê°™ì´í•  ë§Œí¼ ë§¤ìš° ì¹œí•œ ì‚¬ëŒ"
    },
    "å¡ç¿ä¹‹é¦¬": {
        "korean": "ìƒˆì˜¹ì§€ë§ˆ",
        "outer_meaning": "ë³€ë°© ëŠ™ì€ì´ì˜ ë§",
        "inner_meaning": "ì¸ìƒì˜ ê¸¸í‰í™”ë³µì€ ëŠ˜ ë°”ë€Œì–´ ë³€í™”ê°€ ë§ìŒ"
    },
    "ç”¨æ„å‘¨åˆ°": {
        "korean": "ìš©ì˜ì£¼ë„",
        "outer_meaning": "ëœ»ì„ ì“°ê¸°ë¥¼ ë‘ë£¨ ì´ë¥¸ë‹¤",
        "inner_meaning": "ì–´ë–¤ì¼ì„ í•˜ë ¤ê³  ëœ»ì„ ì„¸ìš°ê³  ë§ˆìŒì„ ê°€ì§ì— ìˆì–´ ì¤€ë¹„ê°€ ë‘ë£¨ ë¯¸ì³ ë¹ˆí‹ˆì´ ì—†ìŒ"
    },
    "å­¤è»å¥®é¬ª": {
        "korean": "ê³ êµ°ë¶„íˆ¬",
        "outer_meaning": "ì™¸ë¡œìš´ êµ°ì‚¬ê°€ ë¶„ë°œí•˜ì—¬ ì‹¸ìš´ë‹¤",
        "inner_meaning": "ë”°ë¡œ ë–¨ì–´ì ¸ ë„ì›€ì„ ë°›ì§€ ëª»í•˜ê²Œëœ êµ°ì‚¬ê°€ ë§ì€ ìˆ˜ì˜ ì êµ°ê³¼ ìš©ê°í•˜ê²Œ ì˜ ì‹¸ìš´ë‹¤"
    },
    "åå¯¦ç›¸ç¬¦": {
        "korean": "ëª…ì‹¤ìƒë¶€",
        "outer_meaning": "ì´ë¦„ê³¼ ì‹¤ì œê°€ ì„œë¡œ ë¶€í•©í•œë‹¤",
        "inner_meaning": "ì•Œë ¤ì§„ ê²ƒê³¼ ì‹¤ì œ ë‚´ìš©ì´ ì¼ì¹˜í•¨"
    },
    "ç¾è¾­éº—å¥": {
        "korean": "ë¯¸ì‚¬ì—¬êµ¬",
        "outer_meaning": "ì•„ë¦„ë‹¤ìš´ ë§ê³¼ ê³ ìš´ êµ¬ì ˆ",
        "inner_meaning": "ë‚´ìš©ì€ ì—†ìœ¼ë©´ì„œ ì•„ë¦„ë‹¤ìš´ ë§ë¡œ ë“£ê¸° ì¢‹ê²Œ ê¾¸ë¯¼ ê¸€ê·€"
    },
    "å‰ä»£æœªè": {
        "korean": "ì „ëŒ€ë¯¸ë¬¸",
        "outer_meaning": "ì „ ì‹œëŒ€ì— ë“£ì§€ ëª»í–ˆë‹¤",
        "inner_meaning": "ì´ì œê» ë“¤ì–´ ë³¸ ì ì´ ì—†ë‹¤ëŠ” ëœ»"
    },
    "æœªæ›¾æœ‰": {
        "korean": "ë¯¸ì¦ìœ ",
        "outer_meaning": "ì¼ì°ì´ ìˆì§€ ì•Šì•˜ë‹¤",
        "inner_meaning": "ì „ë¡€ê°€ ì—†ìŒ"
    },
    "ä¸€å ´æ˜¥å¤¢": {
        "korean": "ì¼ì¥ì¶˜ëª½",
        "outer_meaning": "í•œë°”íƒ• ë´„ê¿ˆ",
        "inner_meaning": "í—›ëœ ì˜í™”ë‚˜ ë§ì—†ëŠ” ì¼"
    },
    "é‚¯é„²ä¹‹å¤¢": {
        "korean": "í•œë‹¨ì§€ëª½",
        "outer_meaning": "í•œë‹¨ì˜ ê¿ˆ",
        "inner_meaning": "ì„¸ìƒì˜ ë¶€ê·€ì˜í™”ê°€ í—ˆí™©ëœ"
    },
    "å—æŸ¯ä¸€å¤¢": {
        "korean": "ë‚¨ê°€ì¼ëª½",
        "outer_meaning": "ë‚¨ìª½ ê°€ì§€ì˜ í•œ ê¿ˆ",
        "inner_meaning": "ì¸ìƒì´ë‚˜ ë¶€ê·€ì˜í™”ì˜ ë§ì—†ìŒ"
    },
    "èƒ¡è¶ä¹‹å¤¢": {
        "korean": "í˜¸ì ‘ì§€ëª½",
        "outer_meaning": "ë‚˜ë¹„ì˜ ê¿ˆ",
        "inner_meaning": "ëª°ì•„ì¼ì²´ì˜ ê²½ì§€ ë˜ëŠ” í˜„ì‹¤ê³¼ ê¿ˆì˜ êµ¬ë³„ì´ ì•ˆë˜ì–´ í—ˆë¬´í•¨"
    },
    "ä¸‰ä¸‰äº”äº”": {
        "korean": "ì‚¼ì‚¼ì˜¤ì˜¤",
        "outer_meaning": "ì…‹ì…‹ ë‹¤ì„¯ë‹¤ì„¯",
        "inner_meaning": "ì„œë„ˆ ì‚¬ëŒ ë˜ëŠ” ëŒ€ì—¬ì„¯ ì‚¬ëŒì´ ë–¼ë¥¼ ì§€ì–´ë‹¤ë‹ˆê±°ë‚˜ ë¬´ìŠ¨ ì¼ì„ í•¨"
    },
    "å¤šå¤šç›Šå–„": {
        "korean": "ë‹¤ë‹¤ìµì„ ",
        "outer_meaning": "ë§ìœ¼ë©´ ë§ì„ìˆ˜ë¡ ë”ìš± ì¢‹ë‹¤",
        "inner_meaning": "ë§ìœ¼ë©´ ë§ì„ìˆ˜ë¡ ì¢‹ìŒ"
    },
    "åŒè‹¦åŒæ¨‚": {
        "korean": "ë™ê³ ë™ë½",
        "outer_meaning": "ê³ ìƒë„ ì¦ê±°ì›€ë„ í•¨ê»˜",
        "inner_meaning": "ê´´ë¡œì›€ë„ ì¦ê±°ì›€ë„ í•¨ê»˜í•¨"
    },
    "å„è‡ªåœ–ç”Ÿ": {
        "korean": "ê°ìë„ìƒ",
        "outer_meaning": "ê°ì ì‚´ì•„ê°ˆ ë°©ë²•ì„ ê¾€í•œë‹¤",
        "inner_meaning": "ì œê°ê¸° ì‚´ì•„ ë‚˜ê°ˆ ë°©ë²•ì„ ê¾€í•¨"
    },
    "è«é€†ä¹‹å‹": {
        "korean": "ë§‰ì—­ì§€ìš°",
        "outer_meaning": "ê±°ìŠ¤ë¥´ì§€ ì•ŠëŠ” ë²—",
        "inner_meaning": "í—ˆë¬¼ì—†ì´ ì•„ì£¼ ì¹œí•œ ì¹œêµ¬"
    },
    "ç™¾å¹´ä½³ç´„": {
        "korean": "ë°±ë…„ê°€ì•½",
        "outer_meaning": "ë°±ë…„ì˜ ì•„ë¦„ë‹¤ìš´ ì•½ì†",
        "inner_meaning": "ë‚¨ë…€ê°€ ê²°í˜¼í•˜ì—¬ í‰ìƒì„ í•¨ê»˜ ì§€ë‚¼ê²ƒì„ ë‹¤ì§í•˜ëŠ” ì•„ë¦„ë‹¤ìš´ ì–¸ì•½"
    },
    "å–œå–œæ¨‚æ¨‚": {
        "korean": "í¬í¬ë‚™ë½",
        "outer_meaning": "ê¸°ë»í•˜ê³  ì¦ê±°ì›Œí•œë‹¤",
        "inner_meaning": "ë§¤ìš° ê¸°ë»í•˜ê³  ì¦ê±°ì›Œí•¨"
    },
    "éä¸€éå†": {
        "korean": "ë¹„ì¼ë¹„ì¬",
        "outer_meaning": "í•œ ë²ˆì´ ì•„ë‹ˆê³  ë‘ ë²ˆì´ ì•„ë‹ˆë‹¤",
        "inner_meaning": "ê°™ì€ í˜„ìƒì´ë‚˜ ì¼ì´ í•œë‘ ë²ˆì´ë‚˜ í•œ ë‘˜ì´ ì•„ë‹ˆê³  ë§ìŒ"
    },
    "äº‹å¿…æ­¸æ­£": {
        "korean": "ì‚¬í•„ê·€ì •",
        "outer_meaning": "ì¼ì€ ë°˜ë“œì‹œ ë°”ë¥¸ ê³³ìœ¼ë¡œ ëŒì•„ê°„ë‹¤",
        "inner_meaning": "ëª¨ë“  ì¼ì€ ê²°êµ­ì—ëŠ” ë°˜ë“œì‹œ ë°”ë¥¸ ê¸¸ë¡œ ëŒì•„ê°€ê²Œ ë˜ì–´ ìˆìŒ"
    }
}

# í•œì ë¶„ì„ í•¨ìˆ˜
def analyze_hanja_chars(hanja_string):
    """ì‚¬ìì„±ì–´ì˜ ê° í•œìë¥¼ ë¶„ì„í•˜ì—¬ ëœ»ê³¼ ìŒì„ í‘œì‹œ"""
    chars = list(hanja_string)
    analysis = []
    
    for char in chars:
        if char in HANJA_DATA:
            meaning, sound = HANJA_DATA[char]
            analysis.append(f"{meaning}({char})")
        else:
            analysis.append(f"({char})")
    
    return " ".join(analysis)

# ì„¸ì…˜ ìƒíƒœ ì´ˆê¸°í™”
if 'wrong_answers' not in st.session_state:
    st.session_state.wrong_answers = []
if 'score' not in st.session_state:
    st.session_state.score = {"correct": 0, "total": 0}
if 'current_question' not in st.session_state:
    st.session_state.current_question = None
if 'show_answer' not in st.session_state:
    st.session_state.show_answer = False
if 'speed_quiz_score' not in st.session_state:
    st.session_state.speed_quiz_score = 0
if 'speed_quiz_total' not in st.session_state:
    st.session_state.speed_quiz_total = 0
if 'speed_quiz_start_time' not in st.session_state:
    st.session_state.speed_quiz_start_time = None
if 'exam_questions' not in st.session_state:
    st.session_state.exam_questions = []
if 'exam_current_index' not in st.session_state:
    st.session_state.exam_current_index = 0
if 'exam_answers' not in st.session_state:
    st.session_state.exam_answers = {}
if 'exam_submitted' not in st.session_state:
    st.session_state.exam_submitted = False
if 'exam_results' not in st.session_state:
    st.session_state.exam_results = None
if 'review_list' not in st.session_state:
    st.session_state.review_list = []

def main():
    st.set_page_config(page_title="ğŸ“š í•œì & ì‚¬ìì„±ì–´ í•™ìŠµ", page_icon="ğŸ“š", layout="wide")
    
    # ì‚¬ì´ë“œë°” - ë©”ë‰´ ë° ëª¨ë“  ì„ íƒ ì˜µì…˜
    with st.sidebar:
        st.header("ğŸ“‹ ë©”ë‰´")
        mode = st.selectbox("í•™ìŠµ ëª¨ë“œ ì„ íƒ", [
            "ğŸ  í™ˆ",
            "ğŸ“š ì•”ê¸° ì—°ìŠµ",
            "ğŸ§  í€´ì¦ˆ ëª¨ë“œ", 
            "âš¡ ìŠ¤í”¼ë“œ í€´ì¦ˆ",
            "ğŸ“ ì‹œí—˜ ëª¨ë“œ",
            "ğŸ“Š í•™ìŠµ í†µê³„",
            "ğŸ’¾ ë³µìŠµ ë…¸íŠ¸",
            "ğŸ” ì‚¬ìì„±ì–´ ê²€ìƒ‰"
        ])
        
        st.markdown("---")
        
        # ì•”ê¸° ì—°ìŠµ ëª¨ë“œ ì„¤ì •
        if mode == "ğŸ“š ì•”ê¸° ì—°ìŠµ":
            st.subheader("ğŸ“š ì•”ê¸° ì—°ìŠµ ì„¤ì •")
            practice_type = st.selectbox("ì—°ìŠµ ìœ í˜• ì„ íƒ", [
                "í•œì â†’ ëœ» ë§íˆê¸°",
                "ëœ» â†’ í•œì ë§íˆê¸°", 
                "ì‚¬ìì„±ì–´ â†’ ê²‰ëœ» ë§íˆê¸°",
                "ì‚¬ìì„±ì–´ â†’ ì†ëœ» ë§íˆê¸°",
                "ê²‰ëœ» â†’ ì‚¬ìì„±ì–´ ë§íˆê¸°",
                "ì†ëœ» â†’ ì‚¬ìì„±ì–´ ë§íˆê¸°"
            ])
            
            if st.button("ğŸ¯ ìƒˆ ë¬¸ì œ ì‹œì‘", use_container_width=True):
                generate_memory_question(practice_type)
            
            if st.button("ğŸ”„ ì´ˆê¸°í™”", use_container_width=True):
                st.session_state.current_question = None
                st.session_state.show_answer = False
        
        # í€´ì¦ˆ ëª¨ë“œ ì„¤ì •
        elif mode == "ğŸ§  í€´ì¦ˆ ëª¨ë“œ":
            st.subheader("ğŸ§  í€´ì¦ˆ ì„¤ì •")
            quiz_type = st.selectbox("í€´ì¦ˆ ìœ í˜• ì„ íƒ", [
                "í•œì 4ì§€ì„ ë‹¤",
                "ì‚¬ìì„±ì–´ 4ì§€ì„ ë‹¤ (ê²‰ëœ»)", 
                "ì‚¬ìì„±ì–´ 4ì§€ì„ ë‹¤ (ì†ëœ»)",
                "í•œì O/X í€´ì¦ˆ",
                "ì‚¬ìì„±ì–´ O/X í€´ì¦ˆ (ê²‰ëœ»)",
                "ì‚¬ìì„±ì–´ O/X í€´ì¦ˆ (ì†ëœ»)",
                "í˜¼í•© ëœë¤ í€´ì¦ˆ"
            ])
            
            if st.button("ğŸ¯ í€´ì¦ˆ ì‹œì‘", use_container_width=True):
                generate_quiz_question(quiz_type)
            
            if st.button("ğŸ”„ ì´ˆê¸°í™”", use_container_width=True):
                st.session_state.current_question = None
                st.session_state.show_answer = False

        # ìŠ¤í”¼ë“œ í€´ì¦ˆ ì„¤ì •
        elif mode == "âš¡ ìŠ¤í”¼ë“œ í€´ì¦ˆ":
            st.subheader("âš¡ ìŠ¤í”¼ë“œ í€´ì¦ˆ ì„¤ì •")
            if st.button("ğŸš€ ìŠ¤í”¼ë“œ í€´ì¦ˆ ì‹œì‘", use_container_width=True):
                start_speed_quiz()
            
            if st.button("ğŸ”„ ì´ˆê¸°í™”", use_container_width=True):
                reset_speed_quiz()

        # ì‹œí—˜ ëª¨ë“œ ì„¤ì •
        elif mode == "ğŸ“ ì‹œí—˜ ëª¨ë“œ":
            st.subheader("ğŸ“ ì‹œí—˜ ì„¤ì •")
            if st.button("ğŸ“ ìƒˆ ì‹œí—˜ ì‹œì‘", use_container_width=True):
                generate_exam()
            
            if st.button("ğŸ”„ ì´ˆê¸°í™”", use_container_width=True):
                reset_exam()
        
        # ì‚¬ìì„±ì–´ ê²€ìƒ‰ ì„¤ì •
        elif mode == "ğŸ” ì‚¬ìì„±ì–´ ê²€ìƒ‰":
            st.subheader("ğŸ” ê²€ìƒ‰ ì„¤ì •")
            search_term = st.text_input("ì‚¬ìì„±ì–´ ê²€ìƒ‰:")
            if search_term:
                st.session_state.search_term = search_term
            
            show_all = st.checkbox("ì „ì²´ ëª©ë¡ ë³´ê¸°")
            if show_all:
                st.session_state.show_all_idioms = True
        
        st.markdown("---")
        st.markdown("### ğŸ“ˆ í˜„ì¬ ì ìˆ˜")
        if st.session_state.score["total"] > 0:
            accuracy = (st.session_state.score["correct"] / st.session_state.score["total"]) * 100
            st.metric("ì •ë‹µë¥ ", f"{accuracy:.1f}%")
            st.metric("ì´ ë¬¸ì œ", st.session_state.score["total"])
            st.metric("ì •ë‹µ", st.session_state.score["correct"])
        else:
            st.info("ì•„ì§ ë¬¸ì œë¥¼ í’€ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    
    # ë©”ì¸ ì»¨í…ì¸ 
    if mode == "ğŸ  í™ˆ":
        show_home()
    elif mode == "ğŸ“š ì•”ê¸° ì—°ìŠµ":
        show_memory_practice()
    elif mode == "ğŸ§  í€´ì¦ˆ ëª¨ë“œ":
        show_quiz_mode()
    elif mode == "âš¡ ìŠ¤í”¼ë“œ í€´ì¦ˆ":
        show_speed_quiz()
    elif mode == "ğŸ“ ì‹œí—˜ ëª¨ë“œ":
        show_exam_mode()
    elif mode == "ğŸ“Š í•™ìŠµ í†µê³„":
        show_statistics()
    elif mode == "ğŸ’¾ ë³µìŠµ ë…¸íŠ¸":
        show_review_notes()
    elif mode == "ğŸ” ì‚¬ìì„±ì–´ ê²€ìƒ‰":
        show_idiom_search()

def show_home():
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("ğŸ“– ë°ì´í„° í˜„í™©")
        st.info(f"í•œì: {len(HANJA_DATA)}ê°œ")
        st.info(f"ì‚¬ìì„±ì–´: {len(IDIOM_DATA)}ê°œ")
        st.success(f"ì´ í•™ìŠµ í•­ëª©: {len(HANJA_DATA) + len(IDIOM_DATA)}ê°œ")
    
    with col2:
        st.subheader("ğŸ¯ í•™ìŠµ ëª¨ë“œ")
        st.markdown("""
        **ğŸ“š ì•”ê¸° ì—°ìŠµ ëª¨ë“œ**
        - í•œì â†’ ëœ» ë§íˆê¸°
        - ëœ» â†’ í•œì ë§íˆê¸°
        - ì‚¬ìì„±ì–´ â†’ ëœ» ë§íˆê¸°
        
        **ğŸ§  í€´ì¦ˆ ëª¨ë“œ**
        - 4ì§€ì„ ë‹¤ í€´ì¦ˆ
        - O/X í€´ì¦ˆ
        
        **âš¡ ìŠ¤í”¼ë“œ í€´ì¦ˆ**
        - ë¹ ë¥¸ ì†ë„ì˜ ì—°ì† í€´ì¦ˆ
        
        **ğŸ“ ì‹œí—˜ ëª¨ë“œ**
        - ì‚¬ìì„±ì–´ 20ë¬¸ì œ ì‹œí—˜
        - ì ìˆ˜ ë° ë¶„ì„ ì œê³µ
        """)
    
    st.markdown("---")
    st.subheader("ğŸš€ ë¹ ë¥¸ ì‹œì‘")
    
    col3, col4, col5, col6 = st.columns(4)
    with col3:
        if st.button("ğŸ“š í•œì ì•”ê¸°", use_container_width=True):
            st.session_state.quick_start = "hanja_memory"
    with col4:
        if st.button("ğŸ“œ ì‚¬ìì„±ì–´ ì•”ê¸°", use_container_width=True):
            st.session_state.quick_start = "idiom_memory"
    with col5:
        if st.button("âš¡ ìŠ¤í”¼ë“œ í€´ì¦ˆ", use_container_width=True):
            start_speed_quiz()
    with col6:
        if st.button("ğŸ“ ì‹œí—˜ ë³´ê¸°", use_container_width=True):
            generate_exam()

def show_memory_practice():
    st.header("ğŸ“š ì•”ê¸° ì—°ìŠµ ëª¨ë“œ")
    
    if st.session_state.current_question:
        show_memory_question()

def generate_memory_question(practice_type):
    if "í•œì" in practice_type:
        hanja, (meaning, reading) = random.choice(list(HANJA_DATA.items()))
        if practice_type == "í•œì â†’ ëœ» ë§íˆê¸°":
            st.session_state.current_question = {
                "type": "hanja_to_meaning",
                "question": hanja,
                "answer": f"{meaning} ({reading})",
                "hanja": hanja,
                "meaning": meaning,
                "reading": reading
            }
        else:  # ëœ» â†’ í•œì ë§íˆê¸°
            st.session_state.current_question = {
                "type": "meaning_to_hanja",
                "question": f"{meaning} ({reading})",
                "answer": hanja,
                "hanja": hanja,
                "meaning": meaning,
                "reading": reading
            }
    else:  # ì‚¬ìì„±ì–´
        idiom, data = random.choice(list(IDIOM_DATA.items()))
        korean = data["korean"]
        outer_meaning = data["outer_meaning"]
        inner_meaning = data["inner_meaning"]
        
        if practice_type == "ì‚¬ìì„±ì–´ â†’ ê²‰ëœ» ë§íˆê¸°":
            st.session_state.current_question = {
                "type": "idiom_to_outer",
                "question": f"{idiom}",
                "answer": outer_meaning,
                "idiom": idiom,
                "korean": korean,
                "outer_meaning": outer_meaning,
                "inner_meaning": inner_meaning
            }
        elif practice_type == "ì‚¬ìì„±ì–´ â†’ ì†ëœ» ë§íˆê¸°":
            st.session_state.current_question = {
                "type": "idiom_to_inner",
                "question": f"{idiom}",
                "answer": inner_meaning,
                "idiom": idiom,
                "korean": korean,
                "outer_meaning": outer_meaning,
                "inner_meaning": inner_meaning
            }
        elif practice_type == "ê²‰ëœ» â†’ ì‚¬ìì„±ì–´ ë§íˆê¸°":
            st.session_state.current_question = {
                "type": "outer_to_idiom",
                "question": outer_meaning,
                "answer": f"{idiom}",
                "idiom": idiom,
                "korean": korean,
                "outer_meaning": outer_meaning,
                "inner_meaning": inner_meaning
            }
        else:  # ì†ëœ» â†’ ì‚¬ìì„±ì–´ ë§íˆê¸°
            st.session_state.current_question = {
                "type": "inner_to_idiom",
                "question": inner_meaning,
                "answer": f"{idiom}",
                "idiom": idiom,
                "korean": korean,
                "outer_meaning": outer_meaning,
                "inner_meaning": inner_meaning
            }
    
    st.session_state.show_answer = False

def show_memory_question():
    question = st.session_state.current_question
    
    # ë¬¸ì œ í‘œì‹œ (ë” í° ìƒì)
    st.markdown(f"""
    <div style='font-size: 32px; padding: 40px; background-color: #f0f2f6; 
                border-radius: 15px; text-align: center; margin: 20px 0; 
                border: 2px solid #e1e5e9; box-shadow: 0 2px 4px rgba(0,0,0,0.1);'>
        {question['question']}
    </div>
    """, unsafe_allow_html=True)
    
    # í”Œë˜ì‹œ ì¹´ë“œ í˜•ì‹ - ìƒë‹¨ì— ë²„íŠ¼ 2ê°œ
    col1, col2 = st.columns(2)
    with col1:
        if st.button("ğŸ’¡ ì •ë‹µ í™•ì¸", use_container_width=True, type="primary"):
            st.session_state.show_answer = True
    
    with col2:
        if st.button("â­ï¸ ë‹¤ìŒ ë¬¸ì œ", use_container_width=True):
            practice_type = get_practice_type_from_question(question)
            generate_memory_question(practice_type)
            st.rerun()
    
    # ì •ë‹µ í‘œì‹œ (ì •ë‹µ í™•ì¸ ë²„íŠ¼ì„ ëˆŒë €ì„ ë•Œë§Œ)
    if st.session_state.show_answer:
        st.markdown("### âœ… ì •ë‹µ")
        st.success(f"ì •ë‹µ: {question['answer']}")
        
        # ìƒì„¸ ì •ë³´ í‘œì‹œ
        if "hanja" in question:
            st.markdown("### ğŸ“š ìƒì„¸ ì •ë³´")
            st.info(f"í•œì: {question['hanja']}")
            st.info(f"ëœ»: {question['meaning']}")
            st.info(f"ìŒ: {question['reading']}")
        elif "idiom" in question:
            st.markdown("### ğŸ“š ìƒì„¸ ì •ë³´")
            st.info(f"ì‚¬ìì„±ì–´: {question['idiom']}")
            st.info(f"í•œê¸€: {question['korean']}")
            
            # í•œì ë¶„ì„ ì¶”ê°€
            hanja_analysis = analyze_hanja_chars(question['idiom'])
            st.info(f"í•œì ë¶„ì„: {hanja_analysis}")
            
            st.info(f"ê²‰ëœ»: {question['outer_meaning']}")
            st.info(f"ì†ëœ»: {question['inner_meaning']}")

def get_practice_type_from_question(question):
    if question["type"] == "hanja_to_meaning":
        return "í•œì â†’ ëœ» ë§íˆê¸°"
    elif question["type"] == "meaning_to_hanja":
        return "ëœ» â†’ í•œì ë§íˆê¸°"
    elif question["type"] == "idiom_to_outer":
        return "ì‚¬ìì„±ì–´ â†’ ê²‰ëœ» ë§íˆê¸°"
    elif question["type"] == "idiom_to_inner":
        return "ì‚¬ìì„±ì–´ â†’ ì†ëœ» ë§íˆê¸°"
    elif question["type"] == "outer_to_idiom":
        return "ê²‰ëœ» â†’ ì‚¬ìì„±ì–´ ë§íˆê¸°"
    else:
        return "ì†ëœ» â†’ ì‚¬ìì„±ì–´ ë§íˆê¸°"

def show_quiz_mode():
    st.header("ğŸ§  í€´ì¦ˆ ëª¨ë“œ")
    
    if st.session_state.current_question and st.session_state.current_question.get("quiz_type"):
        show_quiz_question()

def generate_quiz_question(quiz_type):
    if "4ì§€ì„ ë‹¤" in quiz_type:
        generate_multiple_choice_question(quiz_type)
    elif "O/X" in quiz_type:
        generate_ox_question(quiz_type)
    else:  # í˜¼í•© ëœë¤
        random_type = random.choice([
            "í•œì 4ì§€ì„ ë‹¤", "ì‚¬ìì„±ì–´ 4ì§€ì„ ë‹¤ (ê²‰ëœ»)", "ì‚¬ìì„±ì–´ 4ì§€ì„ ë‹¤ (ì†ëœ»)",
            "í•œì O/X í€´ì¦ˆ", "ì‚¬ìì„±ì–´ O/X í€´ì¦ˆ (ê²‰ëœ»)", "ì‚¬ìì„±ì–´ O/X í€´ì¦ˆ (ì†ëœ»)"
        ])
        generate_quiz_question(random_type)

def generate_multiple_choice_question(quiz_type):
    if "í•œì" in quiz_type:
        # í•œì 4ì§€ì„ ë‹¤
        correct_hanja, (correct_meaning, correct_reading) = random.choice(list(HANJA_DATA.items()))
        
        # ì˜¤ë‹µ ì„ íƒì§€ ìƒì„±
        wrong_choices = random.sample([item for item in HANJA_DATA.items() if item[0] != correct_hanja], 3)
        
        choices = [f"{correct_meaning} ({correct_reading})"]
        for _, (meaning, reading) in wrong_choices:
            choices.append(f"{meaning} ({reading})")
        
        random.shuffle(choices)
        correct_answer = choices.index(f"{correct_meaning} ({correct_reading})")
        
        st.session_state.current_question = {
            "quiz_type": "multiple_choice",
            "type": "hanja",
            "question": f"ë‹¤ìŒ í•œìì˜ ëœ»ì€? {correct_hanja}",
            "choices": choices,
            "correct_answer": correct_answer,
            "explanation": f"í•œì '{correct_hanja}'ì˜ ëœ»ì€ '{correct_meaning}'ì´ê³  ìŒì€ '{correct_reading}'ì…ë‹ˆë‹¤."
        }
    else:
        # ì‚¬ìì„±ì–´ 4ì§€ì„ ë‹¤
        correct_idiom, data = random.choice(list(IDIOM_DATA.items()))
        correct_korean = data["korean"]
        
        if "ê²‰ëœ»" in quiz_type:
            correct_meaning = data["outer_meaning"]
            # ë‹¤ë¥¸ ì‚¬ìì„±ì–´ì˜ ê²‰ëœ»ë“¤
            wrong_choices = random.sample([item[1]["outer_meaning"] for item in IDIOM_DATA.items() if item[0] != correct_idiom], 3)
            question_text = f"ë‹¤ìŒ ì‚¬ìì„±ì–´ì˜ ê²‰ëœ»ì€? {correct_idiom}"
        else:  # ì†ëœ»
            correct_meaning = data["inner_meaning"]
            # ë‹¤ë¥¸ ì‚¬ìì„±ì–´ì˜ ì†ëœ»ë“¤
            wrong_choices = random.sample([item[1]["inner_meaning"] for item in IDIOM_DATA.items() if item[0] != correct_idiom], 3)
            question_text = f"ë‹¤ìŒ ì‚¬ìì„±ì–´ì˜ ì†ëœ»ì€? {correct_idiom}"
        
        choices = [correct_meaning] + wrong_choices
        random.shuffle(choices)
        correct_answer = choices.index(correct_meaning)
        
        # í•œì ë¶„ì„ ì¶”ê°€
        hanja_analysis = analyze_hanja_chars(correct_idiom)
        
        st.session_state.current_question = {
            "quiz_type": "multiple_choice",
            "type": "idiom",
            "question": question_text,
            "choices": choices,
            "correct_answer": correct_answer,
            "explanation": f"ì‚¬ìì„±ì–´ '{correct_idiom}({correct_korean})'ì˜ í•œì ë¶„ì„: {hanja_analysis}\nê²‰ëœ»: {data['outer_meaning']}\nì†ëœ»: {data['inner_meaning']}"
        }
    
    st.session_state.show_answer = False

def generate_ox_question(quiz_type):
    if "í•œì" in quiz_type:
        # í•œì O/X í€´ì¦ˆ
        hanja, (meaning, reading) = random.choice(list(HANJA_DATA.items()))
        
        # 50% í™•ë¥ ë¡œ ì •ë‹µ/ì˜¤ë‹µ ë¬¸ì œ ìƒì„±
        is_correct = random.choice([True, False])
        
        if is_correct:
            question_text = f"í•œì '{hanja}'ì˜ ëœ»ì€ '{meaning}'ì´ë‹¤."
            correct_answer = "O"
        else:
            # ë‹¤ë¥¸ í•œìì˜ ëœ»ì„ ê°€ì ¸ì˜´
            wrong_meaning = random.choice([item[1][0] for item in HANJA_DATA.items() if item[0] != hanja])
            question_text = f"í•œì '{hanja}'ì˜ ëœ»ì€ '{wrong_meaning}'ì´ë‹¤."
            correct_answer = "X"
        
        st.session_state.current_question = {
            "quiz_type": "ox",
            "type": "hanja",
            "question": question_text,
            "correct_answer": correct_answer,
            "explanation": f"í•œì '{hanja}'ì˜ ì˜¬ë°”ë¥¸ ëœ»ì€ '{meaning}'({reading})ì…ë‹ˆë‹¤."
        }
    else:
        # ì‚¬ìì„±ì–´ O/X í€´ì¦ˆ
        idiom, data = random.choice(list(IDIOM_DATA.items()))
        korean = data["korean"]
        
        # 50% í™•ë¥ ë¡œ ì •ë‹µ/ì˜¤ë‹µ ë¬¸ì œ ìƒì„±
        is_correct = random.choice([True, False])
        
        if "ê²‰ëœ»" in quiz_type:
            correct_meaning = data["outer_meaning"]
            if is_correct:
                question_text = f"ì‚¬ìì„±ì–´ '{idiom}'ì˜ ê²‰ëœ»ì€ '{correct_meaning}'ì´ë‹¤."
                correct_answer = "O"
            else:
                wrong_meaning = random.choice([item[1]["outer_meaning"] for item in IDIOM_DATA.items() if item[0] != idiom])
                question_text = f"ì‚¬ìì„±ì–´ '{idiom}'ì˜ ê²‰ëœ»ì€ '{wrong_meaning}'ì´ë‹¤."
                correct_answer = "X"
        else:  # ì†ëœ»
            correct_meaning = data["inner_meaning"]
            if is_correct:
                question_text = f"ì‚¬ìì„±ì–´ '{idiom}'ì˜ ì†ëœ»ì€ '{correct_meaning}'ì´ë‹¤."
                correct_answer = "O"
            else:
                wrong_meaning = random.choice([item[1]["inner_meaning"] for item in IDIOM_DATA.items() if item[0] != idiom])
                question_text = f"ì‚¬ìì„±ì–´ '{idiom}'ì˜ ì†ëœ»ì€ '{wrong_meaning}'ì´ë‹¤."
                correct_answer = "X"
        
        # í•œì ë¶„ì„ ì¶”ê°€
        hanja_analysis = analyze_hanja_chars(idiom)
        
        st.session_state.current_question = {
            "quiz_type": "ox",
            "type": "idiom",
            "question": question_text,
            "correct_answer": correct_answer,
            "explanation": f"ì‚¬ìì„±ì–´ '{idiom}({korean})'ì˜ í•œì ë¶„ì„: {hanja_analysis}\nê²‰ëœ»: {data['outer_meaning']}\nì†ëœ»: {data['inner_meaning']}"
        }
    
    st.session_state.show_answer = False

def show_quiz_question():
    question = st.session_state.current_question
    
    # ë¬¸ì œ í‘œì‹œ (ë” í° ìƒì)
    st.markdown(f"""
    <div style='font-size: 24px; padding: 30px; background-color: #f0f2f6; 
                border-radius: 15px; margin: 20px 0; 
                border: 2px solid #e1e5e9; box-shadow: 0 2px 4px rgba(0,0,0,0.1);'>
        {question['question']}
    </div>
    """, unsafe_allow_html=True)
    
    if not st.session_state.show_answer:
        if question["quiz_type"] == "multiple_choice":
            # 4ì§€ì„ ë‹¤
            user_answer = st.radio("ì •ë‹µì„ ì„ íƒí•˜ì„¸ìš”:", 
                                 options=range(len(question["choices"])),
                                 format_func=lambda x: f"{chr(65+x)}. {question['choices'][x]}",
                                 key="quiz_answer")
            
            if st.button("ì •ë‹µ í™•ì¸", use_container_width=True, type="primary"):
                check_quiz_answer(user_answer, question["correct_answer"])
                
        else:
            # O/X í€´ì¦ˆ
            st.markdown("**ì„ íƒí•˜ì„¸ìš”:**")
            col1, col2 = st.columns(2)
            with col1:
                if st.button("â­• A. O (ë§ë‹¤)", use_container_width=True, type="primary"):
                    check_quiz_answer("O", question["correct_answer"])
            with col2:
                if st.button("âŒ B. X (í‹€ë¦¬ë‹¤)", use_container_width=True):
                    check_quiz_answer("X", question["correct_answer"])
    
    # ì •ë‹µ í‘œì‹œ
    if st.session_state.show_answer:
        if hasattr(st.session_state, 'quiz_result'):
            if st.session_state.quiz_result:
                st.success("ğŸ‰ ì •ë‹µì…ë‹ˆë‹¤!")
            else:
                st.error("âŒ í‹€ë ¸ìŠµë‹ˆë‹¤!")
                # í‹€ë¦° ë¬¸ì œë¥¼ ë³µìŠµ ë…¸íŠ¸ì— ì¶”ê°€
                st.session_state.wrong_answers.append({
                    "question": question["question"],
                    "user_answer": st.session_state.user_quiz_answer,
                    "correct_answer": question["correct_answer"],
                    "explanation": question["explanation"],
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                })
        
        st.info(f"ì„¤ëª…: {question['explanation']}")
        
        if st.button("â¡ï¸ ë‹¤ìŒ ë¬¸ì œ", use_container_width=True):
            # ê°™ì€ ìœ í˜•ì˜ ë‹¤ìŒ ë¬¸ì œ ìƒì„±í•˜ê³  ìë™ìœ¼ë¡œ í™”ë©´ ìƒˆë¡œê³ ì¹¨
            if question["quiz_type"] == "multiple_choice":
                if question["type"] == "hanja":
                    generate_quiz_question("í•œì 4ì§€ì„ ë‹¤")
                else:
                    # í˜„ì¬ ë¬¸ì œì—ì„œ ê²‰ëœ»/ì†ëœ» ìœ í˜• íŒŒì•…
                    if "ê²‰ëœ»" in question["question"]:
                        generate_quiz_question("ì‚¬ìì„±ì–´ 4ì§€ì„ ë‹¤ (ê²‰ëœ»)")
                    else:
                        generate_quiz_question("ì‚¬ìì„±ì–´ 4ì§€ì„ ë‹¤ (ì†ëœ»)")
            else:
                if question["type"] == "hanja":
                    generate_quiz_question("í•œì O/X í€´ì¦ˆ")
                else:
                    # í˜„ì¬ ë¬¸ì œì—ì„œ ê²‰ëœ»/ì†ëœ» ìœ í˜• íŒŒì•…
                    if "ê²‰ëœ»" in question["question"]:
                        generate_quiz_question("ì‚¬ìì„±ì–´ O/X í€´ì¦ˆ (ê²‰ëœ»)")
                    else:
                        generate_quiz_question("ì‚¬ìì„±ì–´ O/X í€´ì¦ˆ (ì†ëœ»)")
            
            # í™”ë©´ ìƒˆë¡œê³ ì¹¨
            st.rerun()

def check_quiz_answer(user_answer, correct_answer):
    st.session_state.show_answer = True
    st.session_state.user_quiz_answer = user_answer
    
    # ì ìˆ˜ ì—…ë°ì´íŠ¸
    st.session_state.score["total"] += 1
    
    if user_answer == correct_answer:
        st.session_state.quiz_result = True
        st.session_state.score["correct"] += 1
    else:
        st.session_state.quiz_result = False

# ìŠ¤í”¼ë“œ í€´ì¦ˆ ê¸°ëŠ¥ë“¤
def start_speed_quiz():
    st.session_state.speed_quiz_score = 0
    st.session_state.speed_quiz_total = 0
    st.session_state.speed_quiz_start_time = time.time()
    generate_speed_quiz_question()

def reset_speed_quiz():
    st.session_state.speed_quiz_score = 0
    st.session_state.speed_quiz_total = 0
    st.session_state.speed_quiz_start_time = None
    st.session_state.current_question = None
    st.session_state.show_answer = False

def generate_speed_quiz_question():
    # ëœë¤í•˜ê²Œ í•œì ë˜ëŠ” ì‚¬ìì„±ì–´ ë¬¸ì œ ìƒì„±
    question_type = random.choice(["hanja", "idiom_outer", "idiom_inner"])
    
    if question_type == "hanja":
        hanja, (meaning, reading) = random.choice(list(HANJA_DATA.items()))
        
        # 4ì§€ì„ ë‹¤ ìƒì„±
        wrong_choices = random.sample([item[1] for item in HANJA_DATA.items() if item[0] != hanja], 3)
        choices = [f"{meaning} ({reading})"]
        for m, r in wrong_choices:
            choices.append(f"{m} ({r})")
        
        random.shuffle(choices)
        correct_answer = choices.index(f"{meaning} ({reading})")
        
        st.session_state.current_question = {
            "quiz_type": "speed_multiple_choice",
            "type": "hanja",
            "question": f"{hanja}",
            "choices": choices,
            "correct_answer": correct_answer,
            "explanation": f"í•œì '{hanja}'ì˜ ëœ»ì€ '{meaning}'({reading})ì…ë‹ˆë‹¤."
        }
    
    elif question_type == "idiom_outer":
        idiom, data = random.choice(list(IDIOM_DATA.items()))
        
        # 5ì§€ì„ ë‹¤ ìƒì„±
        wrong_choices = random.sample([item[1]["outer_meaning"] for item in IDIOM_DATA.items() if item[0] != idiom], 4)
        choices = [data["outer_meaning"]] + wrong_choices
        random.shuffle(choices)
        correct_answer = choices.index(data["outer_meaning"])
        
        st.session_state.current_question = {
            "quiz_type": "speed_multiple_choice",
            "type": "idiom",
            "question": f"{idiom}",
            "choices": choices,
            "correct_answer": correct_answer,
            "explanation": f"ì‚¬ìì„±ì–´ '{idiom}({data['korean']})'ì˜ ê²‰ëœ»: {data['outer_meaning']}, ì†ëœ»: {data['inner_meaning']}"
        }
    
    else:  # idiom_inner
        idiom, data = random.choice(list(IDIOM_DATA.items()))
        
        # 5ì§€ì„ ë‹¤ ìƒì„±
        wrong_choices = random.sample([item[1]["inner_meaning"] for item in IDIOM_DATA.items() if item[0] != idiom], 4)
        choices = [data["inner_meaning"]] + wrong_choices
        random.shuffle(choices)
        correct_answer = choices.index(data["inner_meaning"])
        
        st.session_state.current_question = {
            "quiz_type": "speed_multiple_choice",
            "type": "idiom",
            "question": f"{idiom}",
            "choices": choices,
            "correct_answer": correct_answer,
            "explanation": f"ì‚¬ìì„±ì–´ '{idiom}({data['korean']})'ì˜ ê²‰ëœ»: {data['outer_meaning']}, ì†ëœ»: {data['inner_meaning']}"
        }
    
    st.session_state.show_answer = False

def show_speed_quiz():
    st.header("âš¡ ìŠ¤í”¼ë“œ í€´ì¦ˆ")
    
    if st.session_state.speed_quiz_start_time:
        # ê²½ê³¼ ì‹œê°„ í‘œì‹œ
        elapsed_time = time.time() - st.session_state.speed_quiz_start_time
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("ê²½ê³¼ ì‹œê°„", f"{elapsed_time:.1f}ì´ˆ")
        with col2:
            st.metric("ì ìˆ˜", f"{st.session_state.speed_quiz_score}/{st.session_state.speed_quiz_total}")
        with col3:
            if st.session_state.speed_quiz_total > 0:
                accuracy = (st.session_state.speed_quiz_score / st.session_state.speed_quiz_total) * 100
                st.metric("ì •í™•ë„", f"{accuracy:.1f}%")
        
        if st.session_state.current_question:
            show_speed_quiz_question()
    else:
        st.info("ì˜¤ë¥¸ìª½ ì‚¬ì´ë“œë°”ì—ì„œ 'ğŸš€ ìŠ¤í”¼ë“œ í€´ì¦ˆ ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”!")

def show_speed_quiz_question():
    question = st.session_state.current_question
    
    # ë¬¸ì œ í‘œì‹œ (ë” í° ìƒì)
    st.markdown(f"""
    <div style='font-size: 36px; padding: 40px; background-color: #ff6b6b; color: white;
                border-radius: 15px; text-align: center; margin: 20px 0; 
                border: 3px solid #ff5252; box-shadow: 0 4px 8px rgba(0,0,0,0.2);'>
        {question['question']}
    </div>
    """, unsafe_allow_html=True)
    
    if not st.session_state.show_answer:
        # ì„ íƒì§€ë“¤
        st.markdown("**ì„ íƒí•˜ì„¸ìš”:**")
        for i, choice in enumerate(question["choices"]):
            key_letter = chr(65+i)  # A, B, C, D, E
            if st.button(f"{key_letter}. {choice}", use_container_width=True, key=f"speed_{i}"):
                check_speed_quiz_answer(i, question["correct_answer"])
                st.rerun()
    
    # ì •ë‹µ í‘œì‹œ
    if st.session_state.show_answer:
        if hasattr(st.session_state, 'speed_quiz_result'):
            if st.session_state.speed_quiz_result:
                st.success("ğŸ‰ ì •ë‹µ!")
            else:
                st.error("âŒ í‹€ë¦¼!")
        
        st.info(f"ì„¤ëª…: {question['explanation']}")
        
        # ìë™ìœ¼ë¡œ ë‹¤ìŒ ë¬¸ì œë¡œ (1ì´ˆ í›„)
        time.sleep(1)
        generate_speed_quiz_question()
        st.rerun()

def check_speed_quiz_answer(user_answer, correct_answer):
    st.session_state.show_answer = True
    st.session_state.speed_quiz_total += 1
    
    if user_answer == correct_answer:
        st.session_state.speed_quiz_result = True
        st.session_state.speed_quiz_score += 1
    else:
        st.session_state.speed_quiz_result = False

# ì‹œí—˜ ëª¨ë“œ ê¸°ëŠ¥ë“¤
def generate_exam():
    """20ë¬¸ì œ ì‹œí—˜ ìƒì„± (ì‚¬ìì„±ì–´ ì†ëœ» ë§ì¶”ê¸° 10ë¬¸ì œ + ì†ëœ»ìœ¼ë¡œ ì‚¬ìì„±ì–´ ë§ì¶”ê¸° 10ë¬¸ì œ)"""
    st.session_state.exam_questions = []
    st.session_state.exam_current_index = 0
    st.session_state.exam_answers = {}
    st.session_state.exam_submitted = False
    st.session_state.exam_results = None
    
    # ì‚¬ìì„±ì–´ 20ê°œ ì„ íƒ
    selected_idioms = random.sample(list(IDIOM_DATA.items()), 20)
    
    # 1-10ë²ˆ: ì‚¬ìì„±ì–´ â†’ ì†ëœ» ë§ì¶”ê¸° (5ì§€ì„ ë‹¤)
    for i in range(10):
        idiom, data = selected_idioms[i]
        
        # 5ì§€ì„ ë‹¤ ìƒì„±
        wrong_choices = random.sample([item[1]["inner_meaning"] for item in IDIOM_DATA.items() if item[0] != idiom], 4)
        choices = [data["inner_meaning"]] + wrong_choices
        random.shuffle(choices)
        correct_answer = choices.index(data["inner_meaning"])
        
        st.session_state.exam_questions.append({
            "question_num": i + 1,
            "type": "idiom_to_inner",
            "question": f"{idiom}",
            "choices": choices,
            "correct_answer": correct_answer,
            "idiom": idiom,
            "data": data
        })
    
    # 11-20ë²ˆ: ì†ëœ» â†’ ì‚¬ìì„±ì–´ ë§ì¶”ê¸° (5ì§€ì„ ë‹¤)
    for i in range(10, 20):
        idiom, data = selected_idioms[i]
        
        # 5ì§€ì„ ë‹¤ ìƒì„±
        wrong_choices = random.sample([item[0] for item in IDIOM_DATA.items() if item[0] != idiom], 4)
        choices = [idiom] + wrong_choices
        random.shuffle(choices)
        correct_answer = choices.index(idiom)
        
        st.session_state.exam_questions.append({
            "question_num": i + 1,
            "type": "inner_to_idiom",
            "question": data["inner_meaning"],
            "choices": choices,
            "correct_answer": correct_answer,
            "idiom": idiom,
            "data": data
        })

def reset_exam():
    st.session_state.exam_questions = []
    st.session_state.exam_current_index = 0
    st.session_state.exam_answers = {}
    st.session_state.exam_submitted = False
    st.session_state.exam_results = None

def show_exam_mode():
    st.header("ğŸ“ ì‹œí—˜ ëª¨ë“œ")
    
    if not st.session_state.exam_questions:
        st.info("ì˜¤ë¥¸ìª½ ì‚¬ì´ë“œë°”ì—ì„œ 'ğŸ“ ìƒˆ ì‹œí—˜ ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”!")
        return
    
    if st.session_state.exam_submitted:
        show_exam_results()
    else:
        show_exam_question()

def show_exam_question():
    # ì§„í–‰ë¥  í‘œì‹œ
    progress = len(st.session_state.exam_answers) / len(st.session_state.exam_questions)
    st.progress(progress)
    st.write(f"ì§„í–‰ë¥ : {len(st.session_state.exam_answers)}/{len(st.session_state.exam_questions)} ë¬¸ì œ")
    
    # í˜„ì¬ ë¬¸ì œ í‘œì‹œ
    current_q = st.session_state.exam_questions[st.session_state.exam_current_index]
    
    st.markdown(f"### ë¬¸ì œ {current_q['question_num']}")
    
    # ë¬¸ì œ í‘œì‹œ (ë” í° ìƒì)
    if current_q["type"] == "idiom_to_inner":
        question_text = f"ë‹¤ìŒ ì‚¬ìì„±ì–´ì˜ ì†ëœ»ì€?"
        question_main = current_q["question"]
    else:
        question_text = f"ë‹¤ìŒ ì†ëœ»ì— í•´ë‹¹í•˜ëŠ” ì‚¬ìì„±ì–´ëŠ”?"
        question_main = current_q["question"]
    
    st.markdown(f"**{question_text}**")
    st.markdown(f"""
    <div style='font-size: 28px; padding: 30px; background-color: #e3f2fd; 
                border-radius: 15px; text-align: center; margin: 20px 0; 
                border: 2px solid #2196f3; box-shadow: 0 2px 4px rgba(0,0,0,0.1);'>
        {question_main}
    </div>
    """, unsafe_allow_html=True)
    
    # ì„ íƒì§€
    answer_key = f"exam_q_{current_q['question_num']}"
    current_answer = st.session_state.exam_answers.get(current_q['question_num'], None)
    
    user_answer = st.radio(
        "ì •ë‹µì„ ì„ íƒí•˜ì„¸ìš”:",
        options=range(len(current_q["choices"])),
        format_func=lambda x: f"{chr(65+x)}. {current_q['choices'][x]}",
        key=answer_key,
        index=current_answer if current_answer is not None else 0
    )
    
    # ë‹µ ì €ì¥
    st.session_state.exam_answers[current_q['question_num']] = user_answer
    
    # ë„¤ë¹„ê²Œì´ì…˜ ë²„íŠ¼
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.session_state.exam_current_index > 0:
            if st.button("â¬…ï¸ ì´ì „ ë¬¸ì œ"):
                st.session_state.exam_current_index -= 1
                st.rerun()
    
    with col2:
        if len(st.session_state.exam_answers) == len(st.session_state.exam_questions):
            if st.button("âœ… ì‹œí—˜ ì œì¶œ", type="primary"):
                submit_exam()
                st.rerun()
    
    with col3:
        if st.session_state.exam_current_index < len(st.session_state.exam_questions) - 1:
            if st.button("â¡ï¸ ë‹¤ìŒ ë¬¸ì œ"):
                st.session_state.exam_current_index += 1
                st.rerun()

def submit_exam():
    """ì‹œí—˜ ì œì¶œ ë° ì±„ì """
    correct_count = 0
    results = []
    
    for question in st.session_state.exam_questions:
        question_num = question["question_num"]
        user_answer = st.session_state.exam_answers.get(question_num)
        correct_answer = question["correct_answer"]
        
        is_correct = user_answer == correct_answer
        if is_correct:
            correct_count += 1
        
        results.append({
            "question_num": question_num,
            "question": question,
            "user_answer": user_answer,
            "correct_answer": correct_answer,
            "is_correct": is_correct
        })
    
    st.session_state.exam_results = {
        "score": correct_count,
        "total": len(st.session_state.exam_questions),
        "percentage": (correct_count / len(st.session_state.exam_questions)) * 100,
        "results": results
    }
    
    st.session_state.exam_submitted = True

def show_exam_results():
    """ì‹œí—˜ ê²°ê³¼ í‘œì‹œ"""
    results = st.session_state.exam_results
    
    st.header("ğŸ“Š ì‹œí—˜ ê²°ê³¼")
    
    # ì ìˆ˜ í‘œì‹œ
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("ì ìˆ˜", f"{results['score']}/{results['total']}")
    with col2:
        st.metric("ì •ë‹µë¥ ", f"{results['percentage']:.1f}%")
    with col3:
        if results['percentage'] >= 80:
            grade = "A"
            color = "ğŸŸ¢"
        elif results['percentage'] >= 70:
            grade = "B"
            color = "ğŸŸ¡"
        elif results['percentage'] >= 60:
            grade = "C"
            color = "ğŸŸ "
        else:
            grade = "D"
            color = "ğŸ”´"
        st.metric("ë“±ê¸‰", f"{color} {grade}")
    
    # ì„±ê³¼ ë¶„ì„
    if results['percentage'] >= 90:
        st.success("ğŸ‰ ë§¤ìš° ìš°ìˆ˜í•©ë‹ˆë‹¤! ì™„ë²½í•œ ì´í•´ë„ë¥¼ ë³´ì—¬ì£¼ê³  ìˆìŠµë‹ˆë‹¤.")
    elif results['percentage'] >= 80:
        st.success("ğŸ‘ ìš°ìˆ˜í•©ë‹ˆë‹¤! ëŒ€ë¶€ë¶„ì˜ ë‚´ìš©ì„ ì˜ ì´í•´í•˜ê³  ìˆìŠµë‹ˆë‹¤.")
    elif results['percentage'] >= 70:
        st.warning("âš ï¸ ì–‘í˜¸í•©ë‹ˆë‹¤. ì¡°ê¸ˆ ë” í•™ìŠµí•˜ë©´ ë” ì¢‹ì€ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
    elif results['percentage'] >= 60:
        st.warning("ğŸ“š ë” ì—´ì‹¬íˆ ê³µë¶€í•´ì•¼ í•©ë‹ˆë‹¤.")
    else:
        st.error("âŒ ê¸°ì´ˆë¶€í„° ë‹¤ì‹œ í•™ìŠµí•˜ëŠ” ê²ƒì„ ê¶Œí•©ë‹ˆë‹¤.")
    
    # í‹€ë¦° ë¬¸ì œë“¤ì„ ë³µìŠµ ëª©ë¡ì— ì¶”ê°€
    wrong_questions = [r for r in results['results'] if not r['is_correct']]
    if wrong_questions:
        if st.button("ğŸ“ í‹€ë¦° ë¬¸ì œ ë³µìŠµ ëª©ë¡ì— ì¶”ê°€"):
            for wrong in wrong_questions:
                question = wrong['question']
                user_choice = question['choices'][wrong['user_answer']] if wrong['user_answer'] is not None else "ì„ íƒ ì•ˆí•¨"
                correct_choice = question['choices'][wrong['correct_answer']]
                
                # í•œì ë¶„ì„ ì¶”ê°€
                hanja_analysis = analyze_hanja_chars(question['idiom'])
                
                review_item = {
                    "question": question['question'],
                    "user_answer": user_choice,
                    "correct_answer": correct_choice,
                    "explanation": f"ì‚¬ìì„±ì–´: {question['idiom']} ({question['data']['korean']})\ní•œì ë¶„ì„: {hanja_analysis}\nê²‰ëœ»: {question['data']['outer_meaning']}\nì†ëœ»: {question['data']['inner_meaning']}",
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "type": "exam"
                }
                
                # ì¤‘ë³µ í™•ì¸ í›„ ì¶”ê°€
                if review_item not in st.session_state.review_list:
                    st.session_state.review_list.append(review_item)
            
            st.success(f"{len(wrong_questions)}ê°œì˜ í‹€ë¦° ë¬¸ì œê°€ ë³µìŠµ ëª©ë¡ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!")
    
    # ìƒì„¸ ê²°ê³¼
    st.markdown("---")
    st.subheader("ğŸ“‹ ìƒì„¸ ê²°ê³¼")
    
    for result in results['results']:
        question = result['question']
        
        with st.expander(f"ë¬¸ì œ {result['question_num']} - {'âœ… ì •ë‹µ' if result['is_correct'] else 'âŒ ì˜¤ë‹µ'}"):
            if question['type'] == "idiom_to_inner":
                st.markdown(f"**ë¬¸ì œ**: ë‹¤ìŒ ì‚¬ìì„±ì–´ì˜ ì†ëœ»ì€? **{question['question']}**")
            else:
                st.markdown(f"**ë¬¸ì œ**: ë‹¤ìŒ ì†ëœ»ì— í•´ë‹¹í•˜ëŠ” ì‚¬ìì„±ì–´ëŠ”? **{question['question']}**")
            
            if result['user_answer'] is not None:
                st.markdown(f"**ë‚´ ë‹µ**: {question['choices'][result['user_answer']]}")
            else:
                st.markdown(f"**ë‚´ ë‹µ**: ì„ íƒ ì•ˆí•¨")
            
            st.markdown(f"**ì •ë‹µ**: {question['choices'][result['correct_answer']]}")
            
            # ìƒì„¸ ì„¤ëª…
            hanja_analysis = analyze_hanja_chars(question['idiom'])
            st.info(f"""
            **ì‚¬ìì„±ì–´**: {question['idiom']} ({question['data']['korean']})
            **í•œì ë¶„ì„**: {hanja_analysis}
            **ê²‰ëœ»**: {question['data']['outer_meaning']}
            **ì†ëœ»**: {question['data']['inner_meaning']}
            """)

def show_statistics():
    st.header("ğŸ“Š í•™ìŠµ í†µê³„")
    
    # ê¸°ë³¸ í€´ì¦ˆ í†µê³„
    if st.session_state.score["total"] > 0:
        total = st.session_state.score["total"]
        correct = st.session_state.score["correct"]
        wrong = total - correct
        accuracy = (correct / total) * 100
        
        st.subheader("ğŸ§  í€´ì¦ˆ ëª¨ë“œ í†µê³„")
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("ì´ ë¬¸ì œ ìˆ˜", total)
        with col2:
            st.metric("ì •ë‹µ ìˆ˜", correct)
        with col3:
            st.metric("ì˜¤ë‹µ ìˆ˜", wrong)
        with col4:
            st.metric("ì •ë‹µë¥ ", f"{accuracy:.1f}%")
        
        # ì •ë‹µë¥  ì‹œê°í™”
        if accuracy >= 80:
            st.success(f"ğŸ‰ í›Œë¥­í•©ë‹ˆë‹¤! ì •ë‹µë¥ ì´ {accuracy:.1f}%ì…ë‹ˆë‹¤.")
        elif accuracy >= 60:
            st.warning(f"ğŸ‘ ì¢‹ìŠµë‹ˆë‹¤! ì •ë‹µë¥ ì´ {accuracy:.1f}%ì…ë‹ˆë‹¤.")
        else:
            st.error(f"ğŸ’ª ë” ì—´ì‹¬íˆ! ì •ë‹µë¥ ì´ {accuracy:.1f}%ì…ë‹ˆë‹¤.")
        
        # ì§„í–‰ë¥  ë°”
        st.progress(accuracy / 100)
    
    # ìŠ¤í”¼ë“œ í€´ì¦ˆ í†µê³„
    if st.session_state.speed_quiz_total > 0:
        st.markdown("---")
        st.subheader("âš¡ ìŠ¤í”¼ë“œ í€´ì¦ˆ í†µê³„")
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("ì´ ë¬¸ì œ", st.session_state.speed_quiz_total)
        with col2:
            st.metric("ì •ë‹µ", st.session_state.speed_quiz_score)
        with col3:
            speed_accuracy = (st.session_state.speed_quiz_score / st.session_state.speed_quiz_total) * 100
            st.metric("ì •ë‹µë¥ ", f"{speed_accuracy:.1f}%")
    
    # ì‹œí—˜ ê²°ê³¼ í†µê³„
    if st.session_state.exam_results:
        st.markdown("---")
        st.subheader("ğŸ“ ìµœê·¼ ì‹œí—˜ ê²°ê³¼")
        
        results = st.session_state.exam_results
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("ì ìˆ˜", f"{results['score']}/{results['total']}")
        with col2:
            st.metric("ì •ë‹µë¥ ", f"{results['percentage']:.1f}%")
        with col3:
            if results['percentage'] >= 80:
                grade = "A"
            elif results['percentage'] >= 70:
                grade = "B"
            elif results['percentage'] >= 60:
                grade = "C"
            else:
                grade = "D"
            st.metric("ë“±ê¸‰", grade)
    
    # ë³µìŠµ ë…¸íŠ¸ í†µê³„
    st.markdown("---")
    st.subheader("ğŸ’¾ ë³µìŠµ ë…¸íŠ¸ í†µê³„")
    
    total_wrong = len(st.session_state.wrong_answers)
    total_review = len(st.session_state.review_list)
    
    col1, col2 = st.columns(2)
    with col1:
        st.metric("í€´ì¦ˆ í‹€ë¦° ë¬¸ì œ", total_wrong)
    with col2:
        st.metric("ë³µìŠµ ëª©ë¡", total_review)

def show_review_notes():
    st.header("ğŸ’¾ ë³µìŠµ ë…¸íŠ¸")
    
    # íƒ­ìœ¼ë¡œ êµ¬ë¶„
    tab1, tab2 = st.tabs(["ğŸ§  í€´ì¦ˆ í‹€ë¦° ë¬¸ì œ", "ğŸ“ ë³µìŠµ ëª©ë¡"])
    
    with tab1:
        if not st.session_state.wrong_answers:
            st.info("ì•„ì§ í‹€ë¦° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤. í€´ì¦ˆë¥¼ í’€ì–´ë³´ì„¸ìš”!")
        else:
            st.markdown(f"**ì´ {len(st.session_state.wrong_answers)}ê°œì˜ í‹€ë¦° ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤.**")
            
            # ë³µìŠµ ë…¸íŠ¸ ì´ˆê¸°í™” ë²„íŠ¼
            if st.button("ğŸ—‘ï¸ í€´ì¦ˆ í‹€ë¦° ë¬¸ì œ ì´ˆê¸°í™”"):
                st.session_state.wrong_answers = []
                st.success("í€´ì¦ˆ í‹€ë¦° ë¬¸ì œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.")
                st.rerun()
            
            # í‹€ë¦° ë¬¸ì œë“¤ í‘œì‹œ
            for i, item in enumerate(st.session_state.wrong_answers):
                with st.expander(f"âŒ ë¬¸ì œ {i+1} - {item['timestamp']}"):
                    st.markdown(f"**ë¬¸ì œ:** {item['question']}")
                    st.markdown(f"**ë‚´ ë‹µ:** {item['user_answer']}")
                    st.markdown(f"**ì •ë‹µ:** {item['correct_answer']}")
                    st.markdown(f"**ì„¤ëª…:** {item['explanation']}")
    
    with tab2:
        if not st.session_state.review_list:
            st.info("ë³µìŠµ ëª©ë¡ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. ì‹œí—˜ì—ì„œ í‹€ë¦° ë¬¸ì œë¥¼ ì¶”ê°€í•´ë³´ì„¸ìš”!")
        else:
            st.markdown(f"**ì´ {len(st.session_state.review_list)}ê°œì˜ ë³µìŠµ ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤.**")
            
            # ë³µìŠµ ëª©ë¡ ì´ˆê¸°í™” ë²„íŠ¼
            if st.button("ğŸ—‘ï¸ ë³µìŠµ ëª©ë¡ ì´ˆê¸°í™”"):
                st.session_state.review_list = []
                st.success("ë³µìŠµ ëª©ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.")
                st.rerun()
            
            # ë³µìŠµ ë¬¸ì œë“¤ í‘œì‹œ
            for i, item in enumerate(st.session_state.review_list):
                with st.expander(f"ğŸ“š ë³µìŠµ {i+1} - {item['timestamp']}"):
                    st.markdown(f"**ë¬¸ì œ:** {item['question']}")
                    st.markdown(f"**ë‚´ ë‹µ:** {item['user_answer']}")
                    st.markdown(f"**ì •ë‹µ:** {item['correct_answer']}")
                    st.markdown(f"**ì„¤ëª…:** {item['explanation']}")

def show_idiom_search():
    st.header("ğŸ” ì‚¬ìì„±ì–´ ê²€ìƒ‰")
    
    # ê²€ìƒ‰ ê¸°ëŠ¥
    if hasattr(st.session_state, 'search_term') and st.session_state.search_term:
        search_term = st.session_state.search_term
        
        # ê²€ìƒ‰ ê²°ê³¼
        results = []
        for idiom, data in IDIOM_DATA.items():
            if (search_term.lower() in idiom.lower() or 
                search_term.lower() in data["korean"].lower() or
                search_term.lower() in data["outer_meaning"].lower() or
                search_term.lower() in data["inner_meaning"].lower()):
                results.append((idiom, data))
        
        if results:
            st.success(f"ê²€ìƒ‰ ê²°ê³¼: {len(results)}ê°œ")
            
            for idiom, data in results:
                with st.expander(f"ğŸ“œ {idiom} ({data['korean']})"):
                    # í•œì ë¶„ì„
                    hanja_analysis = analyze_hanja_chars(idiom)
                    st.markdown(f"**í•œì ë¶„ì„:** {hanja_analysis}")
                    
                    st.markdown(f"**ê²‰ëœ»:** {data['outer_meaning']}")
                    st.markdown(f"**ì†ëœ»:** {data['inner_meaning']}")
        else:
            st.warning("ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.")
    
    # ì „ì²´ ì‚¬ìì„±ì–´ ëª©ë¡ ë³´ê¸°
    if hasattr(st.session_state, 'show_all_idioms') and st.session_state.show_all_idioms:
        st.markdown(f"### ğŸ“š ì „ì²´ ì‚¬ìì„±ì–´ ({len(IDIOM_DATA)}ê°œ)")
        
        for idiom, data in sorted(IDIOM_DATA.items()):
            st.markdown(f"**{idiom}** ({data['korean']}) - {data['outer_meaning']}")
    
    # ê¸°ë³¸ ì•ˆë‚´ ë©”ì‹œì§€
    if not hasattr(st.session_state, 'search_term') and not hasattr(st.session_state, 'show_all_idioms'):
        st.info("ì™¼ìª½ ì‚¬ì´ë“œë°”ì—ì„œ ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ê±°ë‚˜ ì „ì²´ ëª©ë¡ì„ í™•ì¸í•˜ì„¸ìš”.")

if __name__ == "__main__":
    main()
